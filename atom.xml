<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuckyCrise</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://crisescode.github.io/blog/"/>
  <updated>2020-07-11T15:50:48.176Z</updated>
  <id>https://crisescode.github.io/blog/</id>
  
  <author>
    <name>Crise</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer 第四天</title>
    <link href="https://crisescode.github.io/blog/2020/07/11/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/11/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%9B%9B%E5%A4%A9/</id>
    <published>2020-07-11T15:10:27.000Z</published>
    <updated>2020-07-11T15:50:48.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ4-重建二叉树"><a href="#JZ4-重建二叉树" class="headerlink" title="JZ4 重建二叉树"></a>JZ4 重建二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 [1,2,4,7,3,5,6,8] 和中序遍历序列 [4,7,2,1,5,3,8,6] ，则重建二叉树并返回。</p></blockquote><p><strong>解法思路：</strong><br>使用递归的方法求解。这道题需要对二叉树的性质比较了解，需要熟悉二叉树的几种遍历方式。</p><p><strong>前序遍历是先遍历根节点，然后遍历左节点，最后遍历右节点（根左右）</strong></p><p><strong>中序遍历是先遍历左节点，然后遍历根节点，最后遍历右节点（左根右）</strong></p><p><strong>后序遍历是先遍历左节点，然后遍历右节点，最后遍历根节点（根左右）</strong></p><p>本题给定前序遍历以及中序遍历的序列，可以知道前序遍历第一个值一定是根节点。而根节点在中序遍历中会把左右子树分成两半。因此本题的关键是找到根节点，然后将左右子树依次递归重建得到二叉树。</p><p>使用递归是需要结束条件的，当前序或中序遍历序列为<code>None</code>时，便可推出递归，得到二叉树。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        if not pre or not tin:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        root &#x3D; TreeNode(pre.pop(0))</span><br><span class="line">        index &#x3D; tin.index(root.val)</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; self.reConstructBinaryTree(pre, tin[:index])</span><br><span class="line">        root.right &#x3D; self.reConstructBinaryTree(pre, tin[index + 1:])</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br><span class="line"></span><br><span class="line">    def InOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line">        self.InOrder(root.left)</span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.InOrder(root.right)</span><br><span class="line"></span><br><span class="line">    def BackOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line">        self.BackOrder(root.left)</span><br><span class="line">        self.BackOrder(root.right)</span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br></pre></td></tr></table></figure><p>本题只需写好<code>reConstructBinaryTree</code>这个方法，上面代码其他三个函数是用来前序、中序以及后序遍历重建得到二叉树的，以方便大家调试。<br><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    pre &#x3D; [1, 2, 4, 7, 3, 5, 6, 8]</span><br><span class="line">    tin &#x3D; [4, 7, 2, 1, 5, 3, 8, 6]</span><br><span class="line"></span><br><span class="line">    reTree &#x3D; Solution().reConstructBinaryTree(pre, tin)</span><br><span class="line">    print(&quot;前序遍历：&quot;)</span><br><span class="line">    Solution().preOrder(reTree)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    print(&quot;中序遍历：&quot;)</span><br><span class="line">    Solution().InOrder(reTree)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    print(&quot;后序遍历：&quot;)</span><br><span class="line">    Solution().BackOrder(reTree)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 前序遍历：</span><br><span class="line">1 2 4 7 3 5 6 8 </span><br><span class="line"></span><br><span class="line">中序遍历：</span><br><span class="line">4 7 2 1 5 3 8 6 </span><br><span class="line"></span><br><span class="line">后序遍历：</span><br><span class="line">7 4 2 5 8 6 3 1</span><br></pre></td></tr></table></figure><h3 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h3><p><strong>题目描述：</strong></p><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br> 二叉树的镜像定义如下：</p></blockquote><pre><code> 源二叉树    8   /  \  6   10 / \  / \5  7 9 11镜像二叉树     8   /  \  10   6 / \  / \11 9 7  5</code></pre><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回镜像树的根节点</span><br><span class="line">    def Mirror(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        root.left, root.right &#x3D; \</span><br><span class="line">            self.Mirror(root.right), self.Mirror(root.left)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    tree1 &#x3D; TreeNode(8)</span><br><span class="line">    tree1.left &#x3D; TreeNode(6)</span><br><span class="line">    tree1.right &#x3D; TreeNode(10)</span><br><span class="line">    tree1.left.left &#x3D; TreeNode(5)</span><br><span class="line">    tree1.left.right &#x3D; TreeNode(7)</span><br><span class="line">    tree1.right.left &#x3D; TreeNode(9)</span><br><span class="line">    tree1.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    invert_tree &#x3D; Solution().Mirror(tree1)</span><br><span class="line">    print(Solution().preOrder(invert_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 8 10 11 9 6 7 5 None</span><br></pre></td></tr></table></figure><h3 id="JZ23-二叉搜索树的后序遍历"><a href="#JZ23-二叉搜索树的后序遍历" class="headerlink" title="JZ23 二叉搜索树的后序遍历"></a>JZ23 二叉搜索树的后序遍历</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(sequence) &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        root &#x3D; sequence[-1]</span><br><span class="line">        for index, value in enumerate(sequence):</span><br><span class="line">            if value &gt; root:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for value in sequence[index: -1]:</span><br><span class="line">            if value &lt; root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">        left &#x3D; True</span><br><span class="line">        if index &gt; 0:</span><br><span class="line">            left &#x3D; self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line"></span><br><span class="line">        right &#x3D; True</span><br><span class="line">        if index &lt; len(sequence) - 1:</span><br><span class="line">            right &#x3D; self.VerifySquenceOfBST(sequence[index: -1])</span><br><span class="line"></span><br><span class="line">        return left and right</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    is_binary_tree &#x3D; [1, 3, 5, 9, 12, 10, 7]</span><br><span class="line">    print(Solution().VerifySquenceOfBST(is_binary_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><h3 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h3><p><strong>题目描述：</strong></p><blockquote><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><blockquote><p>输入：8<br>输出：18 </p></blockquote><p><strong>解法思路：</strong></p><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ4-重建二叉树&quot;&gt;&lt;a href=&quot;#JZ4-重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;JZ4 重建二叉树&quot;&gt;&lt;/a&gt;JZ4 重建二叉树&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 [1,2,4,7,3,5,6,8] 和中序遍历序列 [4,7,2,1,5,3,8,6] ，则重建二叉树并返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;使用递归的方法求解。这道题需要对二叉树的性质比较了解，需要熟悉二叉树的几种遍历方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序遍历是先遍历根节点，然后遍历左节点，最后遍历右节点（根左右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序遍历是先遍历左节点，然后遍历根节点，最后遍历右节点（左根右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后序遍历是先遍历左节点，然后遍历右节点，最后遍历根节点（根左右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本题给定前序遍历以及中序遍历的序列，可以知道前序遍历第一个值一定是根节点。而根节点在中序遍历中会把左右子树分成两半。因此本题的关键是找到根节点，然后将左右子树依次递归重建得到二叉树。&lt;/p&gt;
&lt;p&gt;使用递归是需要结束条件的，当前序或中序遍历序列为&lt;code&gt;None&lt;/code&gt;时，便可推出递归，得到二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第三天</title>
    <link href="https://crisescode.github.io/blog/2020/07/08/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/08/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%89%E5%A4%A9/</id>
    <published>2020-07-08T14:33:32.000Z</published>
    <updated>2020-07-11T15:58:13.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ11-二进制中1的个数"><a href="#JZ11-二进制中1的个数" class="headerlink" title="JZ11 二进制中1的个数"></a>JZ11 二进制中1的个数</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p></blockquote><p><strong>解法思路：</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def NumberOf1(self, n):</span><br><span class="line">    # write code here</span><br><span class="line">    count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    if n &lt; 0:</span><br><span class="line">        n &#x3D; n &amp; 0b11111111111111111111111111111111</span><br><span class="line"></span><br><span class="line">    while n !&#x3D; 0:</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        n &#x3D; n &amp; (n - 1)</span><br><span class="line"></span><br><span class="line">    return count</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().NumberOf1(-11))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 30</span><br></pre></td></tr></table></figure><h3 id="JZ27-字符串的排列"><a href="#JZ27-字符串的排列" class="headerlink" title="JZ27 字符串的排列"></a>JZ27 字符串的排列</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p></blockquote><blockquote><p>输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Permutation(self, ss):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JZ47-求1-2-3-…-n"><a href="#JZ47-求1-2-3-…-n" class="headerlink" title="JZ47 求1 + 2 + 3 + … + n"></a>JZ47 求1 + 2 + 3 + … + n</h3><p><strong>题目描述：</strong></p><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; n</span><br><span class="line">        try:</span><br><span class="line">            res % n</span><br><span class="line">            res +&#x3D; self.Sum_Solution(n - 1)</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution2:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; n</span><br><span class="line">        tmp &#x3D; (res and self.Sum_Solution(n - 1))</span><br><span class="line">        res +&#x3D; tmp</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Sum_Solution(5))</span><br><span class="line">    print(Solution2().Sum_Solution(6))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 15</span><br><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="JZ51-构建乘积数组"><a href="#JZ51-构建乘积数组" class="headerlink" title="JZ51 构建乘积数组"></a>JZ51 构建乘积数组</h3><p><strong>题目描述：</strong></p><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def multiply(self, A):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ11-二进制中1的个数&quot;&gt;&lt;a href=&quot;#JZ11-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;JZ11 二进制中1的个数&quot;&gt;&lt;/a&gt;JZ11 二进制中1的个数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第二天</title>
    <link href="https://crisescode.github.io/blog/2020/07/07/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/07/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E5%A4%A9/</id>
    <published>2020-07-07T14:37:49.000Z</published>
    <updated>2020-07-07T15:07:56.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ49-把字符串转化成整数"><a href="#JZ49-把字符串转化成整数" class="headerlink" title="JZ49 把字符串转化成整数"></a>JZ49 把字符串转化成整数</h3><p><strong>题目描述：</strong></p><blockquote><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入描述：<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述：<br>如果是合法的数值表达则返回该数字，否则返回0</p></blockquote><blockquote><p>示例：<br>输入：<br>+2147483647<br>1a33<br>输出：<br>2147483647<br>0</p></blockquote><p><strong>解法思路：</strong><br>使用了一个很巧妙的方法，用一个字典将字符串”0”-“9”与数字0 - 9做一个映射，然后再用数学上计算一个数字的公式得出这个数。比如：<code>123 = (1 * 10 + 2 ) * 10 + 3</code>。需要注意字符串开头的正负号，从而判断得到的数字是整数还是负数。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def StrToInt(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(s) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        str2num &#x3D; &#123;</span><br><span class="line">            &quot;0&quot;: 0, &quot;1&quot;: 1, &quot;2&quot;: 2, &quot;3&quot;: 3, &quot;4&quot;: 4,</span><br><span class="line">            &quot;5&quot;: 5, &quot;6&quot;: 6, &quot;7&quot;: 7, &quot;8&quot;: 8, &quot;9&quot;: 9,</span><br><span class="line">            &quot;+&quot;: 1, &quot;-&quot;: -1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum &#x3D; 0</span><br><span class="line">        sign &#x3D; 1</span><br><span class="line">        for c in s:</span><br><span class="line">            if c in str2num:</span><br><span class="line">                if c &#x3D;&#x3D; &quot;+&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;+&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                if c &#x3D;&#x3D; &quot;-&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;-&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                sum &#x3D; sum * 10 + str2num[c]</span><br><span class="line">            else:</span><br><span class="line">                sum &#x3D; 0</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return sum * sign</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    s &#x3D; &quot;-98210&quot;</span><br><span class="line">    print(Solution().StrToInt(s))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 98210</span><br></pre></td></tr></table></figure><h3 id="JZ7-斐波那契数列"><a href="#JZ7-斐波那契数列" class="headerlink" title="JZ7 斐波那契数列"></a>JZ7 斐波那契数列</h3><p><strong>题目描述：</strong></p><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）(n&lt;=39)。</p></blockquote><p><strong>解法一思路：</strong><br>直接根据数学公式<code>f(n) = f(n - 1) + f(n - 2)</code>，截至条件是当<code>n = 1, f(n) = 1</code>，<code>n = 0, f(0) = 0</code>。利用<strong>递归法</strong>进行求解，这种方法时间复杂度很大，为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line">        else:</span><br><span class="line">            return self.Fibonacci(n-1) + self.Fibonacci(n-2)</span><br></pre></td></tr></table></figure><p><strong>解法二思路：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        n1, n2, n3 &#x3D; 0, 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            n3 &#x3D; n1 + n2</span><br><span class="line">            n1 &#x3D; n2</span><br><span class="line">            n2 &#x3D; n3</span><br><span class="line"></span><br><span class="line">        return n3</span><br></pre></td></tr></table></figure><p><strong>解法三思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution3:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        sum, one &#x3D; 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            sum &#x3D; sum + one</span><br><span class="line">            one &#x3D; sum - one</span><br><span class="line"></span><br><span class="line">        return sum</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Fibonacci(8))</span><br><span class="line">    print(Solution2().Fibonacci(8))</span><br><span class="line">    print(Solution3().Fibonacci(8))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br></pre></td></tr></table></figure><h3 id="JZ48-不用加减乘除做加法"><a href="#JZ48-不用加减乘除做加法" class="headerlink" title="JZ48 不用加减乘除做加法"></a>JZ48 不用加减乘除做加法</h3><p><strong>题目描述：</strong></p><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Add(self, num1, num2):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ49-把字符串转化成整数&quot;&gt;&lt;a href=&quot;#JZ49-把字符串转化成整数&quot; class=&quot;headerlink&quot; title=&quot;JZ49 把字符串转化成整数&quot;&gt;&lt;/a&gt;JZ49 把字符串转化成整数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0&lt;br&gt;输入描述：&lt;br&gt;输入一个字符串,包括数字字母符号,可以为空&lt;br&gt;输出描述：&lt;br&gt;如果是合法的数值表达则返回该数字，否则返回0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;示例：&lt;br&gt;输入：&lt;br&gt;+2147483647&lt;br&gt;1a33&lt;br&gt;输出：&lt;br&gt;2147483647&lt;br&gt;0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;使用了一个很巧妙的方法，用一个字典将字符串”0”-“9”与数字0 - 9做一个映射，然后再用数学上计算一个数字的公式得出这个数。比如：&lt;code&gt;123 = (1 * 10 + 2 ) * 10 + 3&lt;/code&gt;。需要注意字符串开头的正负号，从而判断得到的数字是整数还是负数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第一天</title>
    <link href="https://crisescode.github.io/blog/2020/07/06/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/06/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%80%E5%A4%A9/</id>
    <published>2020-07-06T14:10:47.000Z</published>
    <updated>2020-07-09T13:31:42.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ16-合并两个排序的链表"><a href="#JZ16-合并两个排序的链表" class="headerlink" title="JZ16 合并两个排序的链表"></a>JZ16 合并两个排序的链表</h3><p><strong>题目描述：</strong></p><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><p><strong>解法一思路：</strong><br>使用迭代的方法。先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。</p><p>然后初始化一个新链表，依次比较两个有序链表的值，哪个链表的值较小，则新链表的指针指向该值。继续循环，依次比较，最终返回单调递增的新链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Solution2:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead1 is None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 is None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        node &#x3D; sorted_node &#x3D; ListNode(0)</span><br><span class="line"></span><br><span class="line">        while pHead1 and pHead2:</span><br><span class="line">            if pHead1.val &lt; pHead2.val:</span><br><span class="line">                node.next &#x3D; pHead1</span><br><span class="line">                pHead1 &#x3D; pHead1.next</span><br><span class="line">            else:</span><br><span class="line">                node.next &#x3D; pHead2</span><br><span class="line">                pHead2 &#x3D; pHead2.next</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">        if pHead1 or pHead2:</span><br><span class="line">            node.next &#x3D; pHead1 or pHead2</span><br><span class="line"></span><br><span class="line">        return sorted_node.next</span><br><span class="line"></span><br><span class="line">    def travel_list(self, node):</span><br><span class="line">        while node is not None:</span><br><span class="line">            print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            node &#x3D; node.next</span><br></pre></td></tr></table></figure><p><strong>解法二思路：</strong><br>使用递归的方法。大体思路同上，先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。</p><p>然后依次比较两个有序链表的值，哪个链表的值较小，则将该节点赋值给新链表。使用递归，直至其中一个链表为None，最终返回和并得到的单调递增链表。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead1 is None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 is None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        if pHead1.val &lt; pHead2.val:</span><br><span class="line">            sorted_list &#x3D; pHead1</span><br><span class="line">            sorted_list.next &#x3D; self.Merge(pHead1.next, pHead2)</span><br><span class="line">        else:</span><br><span class="line">            sorted_list &#x3D; pHead2</span><br><span class="line">            sorted_list.next &#x3D; self.Merge(pHead1, pHead2.next)</span><br><span class="line"></span><br><span class="line">        return sorted_list</span><br><span class="line"></span><br><span class="line">    def travel_list(self, node):</span><br><span class="line">        while node is not None:</span><br><span class="line">            print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            node &#x3D; node.next</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    node_1 &#x3D; ListNode(0)</span><br><span class="line">    node_1.next &#x3D; ListNode(4)</span><br><span class="line">    node_1.next.next &#x3D; ListNode(10)</span><br><span class="line">    node_2 &#x3D; ListNode(2)</span><br><span class="line">    node_2.next &#x3D; ListNode(3)</span><br><span class="line">    node_2.next.next &#x3D; ListNode(12)</span><br><span class="line">    solu_1 &#x3D; Solution()</span><br><span class="line">    # print(solu_1.travel_list(solu_1.Merge(node_1, node_2)))</span><br><span class="line">    solu_2 &#x3D; Solution2()</span><br><span class="line">    print(solu_2.travel_list(solu_2.Merge(node_1, node_2)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 2 3 4 10 12 None</span><br></pre></td></tr></table></figure><h3 id="JZ14-链表中倒数第k个结点"><a href="#JZ14-链表中倒数第k个结点" class="headerlink" title="JZ14 链表中倒数第k个结点"></a>JZ14 链表中倒数第k个结点</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><p><strong>解法一思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lass ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 时间复杂度： O(n)</span><br><span class="line">    # 空间复杂度： O(n)</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; []</span><br><span class="line"></span><br><span class="line">        while head is not None:</span><br><span class="line">            res.insert(0, head.val)</span><br><span class="line">            head &#x3D; head.next</span><br><span class="line"></span><br><span class="line">        if len(res) &lt; k or k &lt; 1:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        return res[k-1]</span><br><span class="line"></span><br><span class="line">    def travel_listNode(self, listNode):</span><br><span class="line">        while listNode:</span><br><span class="line">            print(listNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br></pre></td></tr></table></figure><p><strong>解法二思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    # 时间复杂度： O(n)</span><br><span class="line">    # 空间复杂度： O(1)</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        if k &lt; 0 or head is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        slow, fast &#x3D; head, head</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        while fast.next is not None:</span><br><span class="line">            fast &#x3D; fast.next</span><br><span class="line">            if count &gt;&#x3D; k - 1:</span><br><span class="line">                slow &#x3D; slow.next</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        if count &gt;&#x3D; k - 1:</span><br><span class="line">            return slow.val</span><br><span class="line"></span><br><span class="line">        return None</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(4) </span><br><span class="line"></span><br><span class="line">    print(Solution().travel_listNode(curr))</span><br><span class="line">    print(Solution().FindKthToTail(curr, 5))</span><br><span class="line">    print(Solution2().FindKthToTail(curr, 5))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 1 2 3 4 None</span><br><span class="line">&gt;&gt;&gt; 0</span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure><h3 id="JZ15-反转链表"><a href="#JZ15-反转链表" class="headerlink" title="JZ15 反转链表"></a>JZ15 反转链表</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回ListNode</span><br><span class="line">    def ReverseList(self, pHead):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pHead or pHead.next is None:</span><br><span class="line">            return pHead</span><br><span class="line"></span><br><span class="line">        curr, prev &#x3D; pHead, None</span><br><span class="line">        while curr:</span><br><span class="line">            tmp &#x3D; curr.next</span><br><span class="line">            curr.next &#x3D; prev</span><br><span class="line">            prev &#x3D; curr</span><br><span class="line">            curr &#x3D; tmp</span><br><span class="line"></span><br><span class="line">        return prev</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    # print(head)</span><br><span class="line">    print(curr)</span><br><span class="line"></span><br><span class="line">    res &#x3D; Solution().ReverseList(curr)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><h3 id="JZ13-从尾到头打印链表"><a href="#JZ13-从尾到头打印链表" class="headerlink" title="JZ13 从尾到头打印链表"></a>JZ13 从尾到头打印链表</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</span><br><span class="line">    def printListFromTailToHead(self, listNode):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while listNode:</span><br><span class="line">            res.insert(0, listNode.val)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def travel_listNode(self, listNode):</span><br><span class="line">        while listNode:</span><br><span class="line">            print(listNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(4)</span><br><span class="line"></span><br><span class="line">    print(Solution().travel_listNode(curr))</span><br><span class="line">    print(Solution().printListFromTailToHead(curr))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ16-合并两个排序的链表&quot;&gt;&lt;a href=&quot;#JZ16-合并两个排序的链表&quot; class=&quot;headerlink&quot; title=&quot;JZ16 合并两个排序的链表&quot;&gt;&lt;/a&gt;JZ16 合并两个排序的链表&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法一思路：&lt;/strong&gt;&lt;br&gt;使用迭代的方法。先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。&lt;/p&gt;
&lt;p&gt;然后初始化一个新链表，依次比较两个有序链表的值，哪个链表的值较小，则新链表的指针指向该值。继续循环，依次比较，最终返回单调递增的新链表。&lt;/p&gt;
&lt;!--�770--&gt;
&lt;p&gt;&lt;strong&gt;解法二思路：&lt;/strong&gt;&lt;br&gt;使用递归的方法。大体思路同上，先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。&lt;/p&gt;
&lt;p&gt;然后依次比较两个有序链表的值，哪个链表的值较小，则将该节点赋值给新链表。使用递归，直至其中一个链表为None，最终返回和并得到的单调递增链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>NLP（1）文本分类知识梳理</title>
    <link href="https://crisescode.github.io/blog/2020/06/27/NLP%EF%BC%881%EF%BC%89%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>https://crisescode.github.io/blog/2020/06/27/NLP%EF%BC%881%EF%BC%89%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</id>
    <published>2020-06-27T07:17:47.000Z</published>
    <updated>2020-06-27T07:17:47.846Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://crisescode.github.io/blog/2020/06/21/hello-world/"/>
    <id>https://crisescode.github.io/blog/2020/06/21/hello-world/</id>
    <published>2020-06-21T14:21:53.997Z</published>
    <updated>2020-06-18T05:46:18.345Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python之函数式编程模块（2）</title>
    <link href="https://crisescode.github.io/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/"/>
    <id>https://crisescode.github.io/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/</id>
    <published>2020-06-19T06:35:04.000Z</published>
    <updated>2020-06-21T15:13:57.450Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是讲解一些函数式编程常用的模块，比如：<code>itertools</code>, <code>functools</code>以及<code>operator</code>。</p><h2 id="一、itertools-–用以创建迭代器的模块"><a href="#一、itertools-–用以创建迭代器的模块" class="headerlink" title="一、itertools –用以创建迭代器的模块"></a>一、itertools –用以创建迭代器的模块</h2><a id="more"></a><h2 id="二、functools-–-高阶函数可调用对象上的操作"><a href="#二、functools-–-高阶函数可调用对象上的操作" class="headerlink" title="二、functools – 高阶函数可调用对象上的操作"></a>二、functools – 高阶函数可调用对象上的操作</h2><h2 id="三、operator-–-标准运算符替代函数"><a href="#三、operator-–-标准运算符替代函数" class="headerlink" title="三、operator – 标准运算符替代函数"></a>三、operator – 标准运算符替代函数</h2><p>在函数式编程中，我们经常需要把算术运算符当作函数使用，因此可以借助operator模块。operator 模块提供了一套与Python的内置运算符对应的高效率函数。例如，operator.add(x, y) 与表达式 x+y 相同。</p><p>operator 模块为多个算术运算符提供了对应的函数，从而避免编写<br><code>lambda a, b: a * b</code> 这种平凡的匿名函数。这两种做法具体如下：</p><ul><li>使用<code>lambda a, b: a * b</code>匿名函数来计算阶乘：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def fact(n):</span><br><span class="line">...     return reduce(mul, range(1, n+1))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure><ul><li>使用<code>operator.mul</code>函数来计算阶乘：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def fact(n):</span><br><span class="line">...     return reduce(mul, range(1, n+1))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure><p>operator 模块中还有一类函数，能替代从系列中取出元素或读取对象属性的lambda表达式：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是讲解一些函数式编程常用的模块，比如：&lt;code&gt;itertools&lt;/code&gt;, &lt;code&gt;functools&lt;/code&gt;以及&lt;code&gt;operator&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一、itertools-–用以创建迭代器的模块&quot;&gt;&lt;a href=&quot;#一、itertools-–用以创建迭代器的模块&quot; class=&quot;headerlink&quot; title=&quot;一、itertools –用以创建迭代器的模块&quot;&gt;&lt;/a&gt;一、itertools –用以创建迭代器的模块&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://Crisescode.github.io/blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python之函数式编程模块（1）</title>
    <link href="https://crisescode.github.io/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/"/>
    <id>https://crisescode.github.io/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/</id>
    <published>2020-06-19T04:52:51.000Z</published>
    <updated>2020-06-21T15:13:36.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编程方式介绍"><a href="#一、编程方式介绍" class="headerlink" title="一、编程方式介绍"></a>一、编程方式介绍</h2><p>一般编程语言支持通过以下几种方式来解决具体的问题：</p><ul><li>大多数的编程语言都是<strong>过程式</strong>的，也就是我们常说的面向过程的编程方式。而所谓程序是指令的列表，告诉计算机如何处理程序的输入。C、Pascal甚至Unix shell都是过程式语言。</li><li>然后有一些编程语言是<strong>声明式</strong>的，主要是你需要编写一个用来描述待解决问题的说明，然后这个语言的具体实现会指明怎样高效的进行计算并解决问题。SQL 可能是你最熟悉的声明式语言了。 一个 SQL 查询语句描述了你想要检索的数据集，并且 SQL 引擎会决定是扫描整张表还是使用索引，应该先执行哪些子句等等。</li><li><strong>面向对象</strong>编程语言会操作一组对象。其中对象拥有内部状态，并能够以某种方式支持请求和修改这个内部状态的方法。Smalltalk 和 Java 都是面向对象的语言。C++ 和 Python 支持面向对象编程，但并不强制使用面向对象特性。</li><li>而<strong>函数式</strong>编程则是将一个问题分解成一系列函数。理想情况下，函数只接受输入并产生输出，没有任何内部状态会影响为给定输入产生的输出。众所周知的函数式语言包括ML家族(标准ML、OCaml和其他变体)和Haskell。</li></ul><a id="more"></a><p>一般语言设计者在设计语言时，会选择侧重强调一种特定的编程方式，但这会让以不同方式来编写程序变得困难。因此有些语言就被设计成多范式语言，用以支持以上几种不同的编程方式。其中<strong>Lisp，C++ 和 Python 都是多范式语言；使用这些语言，你可以编写主要为过程式，面向对象或者函数式的程序和函数库。</strong>在大型程序中，不同的部分可能会采用不同的方式编写；比如 GUI 可能是面向对象的而处理逻辑则是过程式或者函数式。</p><p>这篇文章主要是来讲解函数式编程，因此接下来主要围绕函数式编程进行展开。</p><h2 id="二、函数式编程"><a href="#二、函数式编程" class="headerlink" title="二、函数式编程"></a>二、函数式编程</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>函数式编程：即为给定输入，输入会流经一系列函数，每个函数接收输入并输出结果。并且这个过程，在每个函数内部并不会修改全局变量或者有其他副作用。函数式编程允许把函数本身作为参数传入另一个函数，还允许返回一个函数。</p><h3 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a>2.2 特点</h3><p>函数式风格有其理论和实践上的优点：</p><ul><li>形式证明</li><li>模块化</li><li>组合性</li><li>易于调试和测试</li></ul><h2 id="三、函数式编程实践"><a href="#三、函数式编程实践" class="headerlink" title="三、函数式编程实践"></a>三、函数式编程实践</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、编程方式介绍&quot;&gt;&lt;a href=&quot;#一、编程方式介绍&quot; class=&quot;headerlink&quot; title=&quot;一、编程方式介绍&quot;&gt;&lt;/a&gt;一、编程方式介绍&lt;/h2&gt;&lt;p&gt;一般编程语言支持通过以下几种方式来解决具体的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大多数的编程语言都是&lt;strong&gt;过程式&lt;/strong&gt;的，也就是我们常说的面向过程的编程方式。而所谓程序是指令的列表，告诉计算机如何处理程序的输入。C、Pascal甚至Unix shell都是过程式语言。&lt;/li&gt;
&lt;li&gt;然后有一些编程语言是&lt;strong&gt;声明式&lt;/strong&gt;的，主要是你需要编写一个用来描述待解决问题的说明，然后这个语言的具体实现会指明怎样高效的进行计算并解决问题。SQL 可能是你最熟悉的声明式语言了。 一个 SQL 查询语句描述了你想要检索的数据集，并且 SQL 引擎会决定是扫描整张表还是使用索引，应该先执行哪些子句等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向对象&lt;/strong&gt;编程语言会操作一组对象。其中对象拥有内部状态，并能够以某种方式支持请求和修改这个内部状态的方法。Smalltalk 和 Java 都是面向对象的语言。C++ 和 Python 支持面向对象编程，但并不强制使用面向对象特性。&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;函数式&lt;/strong&gt;编程则是将一个问题分解成一系列函数。理想情况下，函数只接受输入并产生输出，没有任何内部状态会影响为给定输入产生的输出。众所周知的函数式语言包括ML家族(标准ML、OCaml和其他变体)和Haskell。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://Crisescode.github.io/blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>My first post</title>
    <link href="https://crisescode.github.io/blog/2020/06/18/My-first-post/"/>
    <id>https://crisescode.github.io/blog/2020/06/18/My-first-post/</id>
    <published>2020-06-18T06:01:38.000Z</published>
    <updated>2020-06-18T06:01:38.066Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
