<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuckyCrise</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://crisescode.github.io/blog/"/>
  <updated>2021-01-13T14:20:23.514Z</updated>
  <id>https://crisescode.github.io/blog/</id>
  
  <author>
    <name>Crise</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 年终总结</title>
    <link href="https://crisescode.github.io/blog/2021/01/12/2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://crisescode.github.io/blog/2021/01/12/2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-12T15:09:00.000Z</published>
    <updated>2021-01-13T14:20:23.514Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来自己是不喜欢将一些总结放到博客里来的，感觉这个还是挺私密的，是自己一年的发展回顾。但是看了很多大佬的博客，他们都很擅于总结自己的一年，并且也会将之发到自己的博客上，我感觉这样也挺好的。自己之前都是将这些总结放到本地存储，但这样有时写了一会就不想去写了，很容易虎头蛇尾。因此我决定以后可以将一些总结，感触什么的放到博客里，以此来监督自己一直坚持下去~</p><p>2020，一个不平凡的一年，这整年人人都基本是带着口罩过来的，直到现在还是无法摆脱带口罩，每天出行仍需带着上地铁，进公司。在年初，因为疫情影响，相信很多人都是被困在家远程办公。刚开始在家办公，自己还是不适应的，没有公司的那种开发氛围，很多需求也不能面对面及时的沟通得以解决，这样还是挺不方便的。但是后来，随着在家办公的时间长了，感觉在家办公也不错，至少节省了上下班通勤路上的时间，每天从床上爬起来就可以投入工作，这种感觉还是挺好的。当然这样对于大多数人工作效率肯定是很低的，所以公司还是会尽量要求员工在家隔离完就需要回公司办公了，因此自己大概在今年3月份回到联想大厦办公了。</p><a id="more"></a><p>其实自己在年初的时候给自己的2020定了一些计划的，但是关于实现与否，还真是偏差甚远。首先是打算这一年换一份工作的，最好是NLP算法工程师相关的工作。在今年的前三个月里，自己还是很认真的在学习NLP相关的知识，但是后面发现自己还是很难去找这相关的工作，加上后面在联想又大部分时间在做开发相关的工作，所以后面也就没再学习了。关于跳槽，从今年8月份开始更新几个网站的简历，然后也是8月份开始陆续接到了很多猎头的电话，也面试了很多了公司，最终拿了几个offer，待遇什么的较联想这边也有一定的涨幅。最后选择了一家互联网+金融的公司，信也科技，但不是算法相关的岗位，不过也挺符合自己的发展方向的，目前主要是机器学习容器云平台开发，主要是<br>Python / Go 作为技术栈, 基于 Kubernetes / Docker 打造基于云原生上传数据集，标注，特征提取，训练以及模型部署一体化的机器学习平台。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来自己是不喜欢将一些总结放到博客里来的，感觉这个还是挺私密的，是自己一年的发展回顾。但是看了很多大佬的博客，他们都很擅于总结自己的一年，并且也会将之发到自己的博客上，我感觉这样也挺好的。自己之前都是将这些总结放到本地存储，但这样有时写了一会就不想去写了，很容易虎头蛇尾。因此我决定以后可以将一些总结，感触什么的放到博客里，以此来监督自己一直坚持下去~&lt;/p&gt;
&lt;p&gt;2020，一个不平凡的一年，这整年人人都基本是带着口罩过来的，直到现在还是无法摆脱带口罩，每天出行仍需带着上地铁，进公司。在年初，因为疫情影响，相信很多人都是被困在家远程办公。刚开始在家办公，自己还是不适应的，没有公司的那种开发氛围，很多需求也不能面对面及时的沟通得以解决，这样还是挺不方便的。但是后来，随着在家办公的时间长了，感觉在家办公也不错，至少节省了上下班通勤路上的时间，每天从床上爬起来就可以投入工作，这种感觉还是挺好的。当然这样对于大多数人工作效率肯定是很低的，所以公司还是会尽量要求员工在家隔离完就需要回公司办公了，因此自己大概在今年3月份回到联想大厦办公了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[GO] — 解析 GOROOT、GOPATH 以及 UBUNTU 中构建 golang 项目</title>
    <link href="https://crisescode.github.io/blog/2020/12/27/GO-%E2%80%94-%E8%A7%A3%E6%9E%90-GOROOT%E3%80%81GOPATH-%E4%BB%A5%E5%8F%8A-UBUNTU-%E4%B8%AD%E6%9E%84%E5%BB%BA-golang-%E9%A1%B9%E7%9B%AE/"/>
    <id>https://crisescode.github.io/blog/2020/12/27/GO-%E2%80%94-%E8%A7%A3%E6%9E%90-GOROOT%E3%80%81GOPATH-%E4%BB%A5%E5%8F%8A-UBUNTU-%E4%B8%AD%E6%9E%84%E5%BB%BA-golang-%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-12-27T08:26:31.000Z</published>
    <updated>2020-12-27T08:29:42.885Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="GO" scheme="https://Crisescode.github.io/blog/categories/GO/"/>
    
    
      <category term="gopath" scheme="https://Crisescode.github.io/blog/tags/gopath/"/>
    
      <category term="go-modules" scheme="https://Crisescode.github.io/blog/tags/go-modules/"/>
    
  </entry>
  
  <entry>
    <title>[GO] golang学习之interface接口</title>
    <link href="https://crisescode.github.io/blog/2020/12/26/GO-%E2%80%94-Golang%E5%AD%A6%E4%B9%A0%E4%B9%8Binterface%E6%8E%A5%E5%8F%A3/"/>
    <id>https://crisescode.github.io/blog/2020/12/26/GO-%E2%80%94-Golang%E5%AD%A6%E4%B9%A0%E4%B9%8Binterface%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-12-26T14:17:21.000Z</published>
    <updated>2020-12-26T14:19:18.608Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="GO" scheme="https://Crisescode.github.io/blog/categories/GO/"/>
    
    
      <category term="interface" scheme="https://Crisescode.github.io/blog/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>[Kubernetes] 认识一下Kubernetes</title>
    <link href="https://crisescode.github.io/blog/2020/10/29/Kubernetes-%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8BKubernetes/"/>
    <id>https://crisescode.github.io/blog/2020/10/29/Kubernetes-%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8BKubernetes/</id>
    <published>2020-10-29T14:20:45.000Z</published>
    <updated>2020-10-29T14:20:45.809Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[LeetCode] 数据结构之树</title>
    <link href="https://crisescode.github.io/blog/2020/10/18/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/"/>
    <id>https://crisescode.github.io/blog/2020/10/18/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/</id>
    <published>2020-10-18T15:44:43.000Z</published>
    <updated>2020-10-18T15:48:29.397Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="leetcode" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/leetcode/"/>
    
    
      <category term="树" scheme="https://Crisescode.github.io/blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[AI] 模型部署实践（2）Tensorflow Serving 部署方式</title>
    <link href="https://crisescode.github.io/blog/2020/09/29/AI-%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%EF%BC%882%EF%BC%89Tensorflow-Serving%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/"/>
    <id>https://crisescode.github.io/blog/2020/09/29/AI-%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%EF%BC%882%EF%BC%89Tensorflow-Serving%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/</id>
    <published>2020-09-29T07:46:26.000Z</published>
    <updated>2020-09-29T07:54:53.769Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="AI" scheme="https://Crisescode.github.io/blog/categories/AI/"/>
    
      <category term="模型部署" scheme="https://Crisescode.github.io/blog/categories/AI/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="TF Serving" scheme="https://Crisescode.github.io/blog/tags/TF-Serving/"/>
    
  </entry>
  
  <entry>
    <title>[Kubernetes] 基于kubeadm搭建一个完整的Kubernetes集群</title>
    <link href="https://crisescode.github.io/blog/2020/09/29/Kubernetes-%E5%9F%BA%E4%BA%8Ekubeadm%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Kubernetes%E9%9B%86%E7%BE%A4/"/>
    <id>https://crisescode.github.io/blog/2020/09/29/Kubernetes-%E5%9F%BA%E4%BA%8Ekubeadm%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Kubernetes%E9%9B%86%E7%BE%A4/</id>
    <published>2020-09-29T01:42:25.000Z</published>
    <updated>2020-10-28T14:21:50.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 是 Google 于 2014 年 6 月基于其内部使用的 Borg 系统开源出来的容器编排调度引擎，Google 将其作为初始和核心项目贡献给 CNCF（云原生计算基金会），近年来逐渐发展出了云原生生态。</p><p>Kubernetes 的目标不仅仅是一个编排系统，而是提供一个规范用以描述集群的架构，定义服务的最终状态，使系统自动地达到和维持该状态。Kubernetes 作为云原生应用的基石，相当于一个云操作系统，其重要性不言而喻。</p><h3 id="为什么需要-Kubernetes，它能做什么"><a href="#为什么需要-Kubernetes，它能做什么" class="headerlink" title="为什么需要 Kubernetes，它能做什么?"></a>为什么需要 Kubernetes，它能做什么?</h3><p>容器是打包和运行应用程序的好方式。在生产环境中，您需要管理运行应用程序的容器，并确保不会停机。例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？</p><p>这就是 Kubernetes 的救援方法！Kubernetes 为您提供了一个可弹性运行分布式系统的框架。Kubernetes 会满足您的扩展要求、故障转移、部署模式等。例如，Kubernetes 可以轻松管理系统的 Canary 部署。</p><p>Kubernetes 能够提供以下一些功能：</p><a id="more"></a><ul><li>服务发现和负载均衡<br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果到容器的流量很大，    Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li><li>存储编排<br>Kubernetes 允许您自动挂载您选择的存储系统，例如本地存储、公共云提供商等。</li><li>自动部署和回滚<br>您可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为所需状态。例如，您可以自动化 Kubernetes 来为您的部署创建新容器，删除现有容器并将它们的所有资源用于新容器。</li><li>自动二进制打包<br>Kubernetes 允许您指定每个容器所需 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</li><li>自我修复<br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li><li>密钥与配置管理<br>Kubernetes 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li></ul><p>因此综上，我们需要好好学习 Kubernetes 这个强大的云操作系统，增强自身的竞争力。工欲善其事，必先利其器，本篇也是 Kubernetes 系列的第一篇博文，讲述如何利用 Kubeadm 这个工具来搭建一套供自己学习的 Kubernetes 集群。</p><h2 id="Kubeadm-到底是什么？"><a href="#Kubeadm-到底是什么？" class="headerlink" title="Kubeadm 到底是什么？"></a>Kubeadm 到底是什么？</h2><p>Kubeadm 能够用以创建一个符合最佳实践的最小化 Kubernetes 集群。事实上，你可以使用 kubeadm 配置一个通过 Kubernetes 一致性测试的集群。 kubeadm 还支持其他集群生命周期功能， 例如：启动引导令牌和集群升级。</p><p>kubeadm 工具很棒，如果你需要：</p><ul><li>一个尝试 Kubernetes 的简单方法。</li><li>一个现有用户可以自动设置集群并测试其应用程序的途径。</li><li>其他具有更大范围的生态系统和/或安装工具中的构建模块。</li></ul><p>你可以在各种机器上安装和使用 kubeadm：笔记本电脑， 一组云服务器，Raspberry Pi 等。无论是部署到云还是本地，你都可以将 kubeadm 集成到预配置系统中，例如 Ansible 或 Terraform。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>一台或多台运行着下列系统的机器，去阿里云申请或者自己物理机用 VMvare 新建都行：<ul><li>Ubuntu 16.04+</li><li>Debian 9+</li><li>CentOS 7</li><li>Red Hat Enterprise Linux (RHEL) 7</li><li>Fedora 25+</li><li>HypriotOS v1.0.1+</li><li>Container Linux (测试 1800.6.0 版本)</li></ul></li><li>单机可用资源建议 2 核 CPU、8 GB 内存或以上，再小的话问题也不大，但是能调度的 Pod 数量就比较有限了</li><li>每台机器能够访问外网，因为需要拉取镜像</li><li>集群中所有计算机之间具有完全的网络连接</li></ul><h2 id="安装-Kubeadm-以及-Docker"><a href="#安装-Kubeadm-以及-Docker" class="headerlink" title="安装 Kubeadm 以及 Docker"></a>安装 Kubeadm 以及 Docker</h2><p>上述介绍过 kubeadm 的基础用法，接下来我将会介绍基于 Centos 8 安装 Kubernetes 组件以及 Docker。</p><h3 id="配置安装源"><a href="#配置安装源" class="headerlink" title="配置安装源"></a>配置安装源</h3><ul><li>配置<code>docker</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li><li>配置<code>kubernetes</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">repo_gpgcheck&#x3D;0</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li>本地缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dnf makecache</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装-Kubeadm-以及-docker"><a href="#安装-Kubeadm-以及-docker" class="headerlink" title="安装 Kubeadm 以及 docker"></a>安装 Kubeadm 以及 docker</h3><ul><li>执行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ dnf -y install docker-ce</span><br><span class="line">$ systemctl enable docker</span><br><span class="line">$ systemctl start docker</span><br><span class="line">$ dnf install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br></pre></td></tr></table></figure></li></ul><p>这里安装了 Docker 公司发布的最新的 Docker CE（社区版），Kubernetes 相关的组件安装的 1.18.0 版本，基本是目前为止最新的版本了。</p><h2 id="部署-Kubernetes-的-Master-节点"><a href="#部署-Kubernetes-的-Master-节点" class="headerlink" title="部署 Kubernetes 的 Master 节点"></a>部署 Kubernetes 的 Master 节点</h2><p>利用 kubeadm 可以很简单的来初始化 kubernetes 集群的 master 节点，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address&#x3D;192.168.0.2 \</span><br><span class="line">  --kubernetes-version v1.18.0 \</span><br><span class="line">  --service-cidr&#x3D;10.1.0.0&#x2F;16 \</span><br><span class="line">  --pod-network-cidr&#x3D;10.244.0.0&#x2F;16</span><br><span class="line">  </span><br><span class="line"> If you can&#39;t access foreign websites:</span><br><span class="line">  kubeadm init \</span><br><span class="line">  --apiserver-advertise-address&#x3D;192.168.0.2 \</span><br><span class="line">  --image-repository registry.aliyuncs.com&#x2F;google_containers \</span><br><span class="line">  --kubernetes-version v1.18.0 \</span><br><span class="line">  --service-cidr&#x3D;10.1.0.0&#x2F;16 \</span><br><span class="line">  --pod-network-cidr&#x3D;10.244.0.0&#x2F;16</span><br></pre></td></tr></table></figure><p>上述命令行参数解释：</p><ul><li><code>--apiserver-advertise-address</code>：可用于为控制平面节点的 API server 设置广播地址，</li></ul><h2 id="部署网络插件"><a href="#部署网络插件" class="headerlink" title="部署网络插件"></a>部署网络插件</h2><p>在 Kubernetes 项目“一切皆容器”的设计理念指导下，部署网络插件也是通过启动<code>pod</code>的形式来配置网络，其中有两种网络插件可供部署：</p><ul><li>部署 flannel 网络插件（详细介绍后面会在开一篇博文）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;a70459be0084506e4ec919aa1c114638878db11b&#x2F;Documentation&#x2F;kube-flannel.yml</span><br><span class="line">update:  https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;v0.12.0&#x2F;Documentation&#x2F;kube-flannel.yml</span><br></pre></td></tr></table></figure></li><li>部署 calico 网络插件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;docs.projectcalico.org&#x2F;v3.14&#x2F;manifests&#x2F;calico.yaml</span><br></pre></td></tr></table></figure>上述两个网络插件只需部署一个即可，部署成功与否可通过查看对应 pod 的运行状态即可：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -n kube-system</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-65f8bc95db-ngv7v   1&#x2F;1     Running   0          3d19h</span><br><span class="line">calico-node-9sr5c                          1&#x2F;1     Running   0          3d19h</span><br><span class="line">calico-node-jtt5w                          1&#x2F;1     Running   0          3d19h</span><br><span class="line">coredns-7ff77c879f-v645l                   1&#x2F;1     Running   0          3d19h</span><br><span class="line">coredns-7ff77c879f-vdrcf                   1&#x2F;1     Running   0          3d19h</span><br><span class="line">etcd-master                                1&#x2F;1     Running   1          3d20h</span><br><span class="line">kube-apiserver-master                      1&#x2F;1     Running   1          3d20h</span><br><span class="line">kube-controller-manager-master             1&#x2F;1     Running   1          3d20h</span><br><span class="line">kube-proxy-sbxzb                           1&#x2F;1     Running   0          3d19h</span><br><span class="line">kube-proxy-xfw7t                           1&#x2F;1     Running   0          3d19h</span><br><span class="line">kube-scheduler-master                      1&#x2F;1     Running   1          3d20h</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，所有的系统 Pod 都成功启动了，而刚刚部署的 calico 网络插件则在 kube-system 下面新建了一个名叫 calico-kube-controllers-65f8bc95db-ngv7v 的 Pod，一般来说，这些 Pod 就是容器网络插件在每个节点上的控制组件。</p><p>Kubernetes 支持容器网络插件，使用的是一个名叫 CNI 的通用接口，它也是当前容器网络的事实标准，市面上的所有容器网络开源项目都可以通过 CNI 接入 Kubernetes，比如 Flannel、Calico、Canal、Romana 等等，它们的部署方式也都是类似的“一键部署”。关于这些开源项目的实现细节和差异，后续会有相关的博文进行详细讲解。</p><p>至此，Kubernetes 的 Master 节点就部署完成了。如果你只需要一个单节点的 Kubernetes，现在你就可以使用了。不过，在默认情况下，Kubernetes 的 Master 节点是不能运行用户 Pod 的，所以还需要额外做一个小操作。在本篇的最后部分，我会介绍到它。</p><h2 id="部署-Kubernetes-的计算节点"><a href="#部署-Kubernetes-的计算节点" class="headerlink" title="部署 Kubernetes 的计算节点"></a>部署 Kubernetes 的计算节点</h2><p>Kubernetes 的 计算节点跟 Master 节点几乎是相同的，它们运行着的都是一个 kubelet 组件。唯一的区别在于，在 kubeadm init 的过程中，kubelet 启动后，Master 节点上还会自动运行 kube-apiserver、kube-scheduler、kube-controller-manger 这三个系统 Pod。<br>执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm join 192.168.56.12:6443 --token japatq.5vib0jhpgmeeqsb2 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c08f2729dbe9e2b1ce9f44e6d3159c493cc686b2e93dc252f7658cb26b87d726</span><br></pre></td></tr></table></figure><p>用以加入<code>192.168.56.12</code>这个 IP 的计算节点到集群中，以上<code>Token</code>可用<code>kubeclt token list</code>得到。</p><p>通过执行以上步骤便可以搭建好一个网络完整的 Kubernetes 集群。当然，也可以继续往集群中添加其他的插件，比如部署 Dashboard 可视化插件，部署容器存储插件等等。这个就因人而异了，留给大家自由发挥了…</p><h2 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h2><ul><li>列出集群的节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES    AGE   VERSION</span><br><span class="line">master   Ready    master   33d   v1.18.0</span><br><span class="line">node     Ready    &lt;none&gt;   33d   v1.18.0</span><br></pre></td></tr></table></figure></li><li>列出系统的<code>pod</code>资源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl get pod -n kube-system</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-65f8bc95db-ngv7v   1&#x2F;1     Running   0          33d</span><br><span class="line">calico-node-9sr5c                          1&#x2F;1     Running   0          33d</span><br><span class="line">calico-node-jtt5w                          1&#x2F;1     Running   0          33d</span><br><span class="line">coredns-7ff77c879f-v645l                   1&#x2F;1     Running   0          33d</span><br><span class="line">coredns-7ff77c879f-vdrcf                   1&#x2F;1     Running   0          33d</span><br><span class="line">etcd-master                                1&#x2F;1     Running   1          33d</span><br><span class="line">kube-apiserver-master                      1&#x2F;1     Running   1          33d</span><br><span class="line">kube-controller-manager-master             1&#x2F;1     Running   1          33d</span><br><span class="line">kube-proxy-sbxzb                           1&#x2F;1     Running   0          33d</span><br><span class="line">kube-proxy-xfw7t                           1&#x2F;1     Running   0          33d</span><br><span class="line">kube-scheduler-master                      1&#x2F;1     Running   1          33d</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">使用 kubeadm 创建集群</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/overview/" target="_blank" rel="noopener">Kubernetes概述</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 是 Google 于 2014 年 6 月基于其内部使用的 Borg 系统开源出来的容器编排调度引擎，Google 将其作为初始和核心项目贡献给 CNCF（云原生计算基金会），近年来逐渐发展出了云原生生态。&lt;/p&gt;
&lt;p&gt;Kubernetes 的目标不仅仅是一个编排系统，而是提供一个规范用以描述集群的架构，定义服务的最终状态，使系统自动地达到和维持该状态。Kubernetes 作为云原生应用的基石，相当于一个云操作系统，其重要性不言而喻。&lt;/p&gt;
&lt;h3 id=&quot;为什么需要-Kubernetes，它能做什么&quot;&gt;&lt;a href=&quot;#为什么需要-Kubernetes，它能做什么&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 Kubernetes，它能做什么?&quot;&gt;&lt;/a&gt;为什么需要 Kubernetes，它能做什么?&lt;/h3&gt;&lt;p&gt;容器是打包和运行应用程序的好方式。在生产环境中，您需要管理运行应用程序的容器，并确保不会停机。例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？&lt;/p&gt;
&lt;p&gt;这就是 Kubernetes 的救援方法！Kubernetes 为您提供了一个可弹性运行分布式系统的框架。Kubernetes 会满足您的扩展要求、故障转移、部署模式等。例如，Kubernetes 可以轻松管理系统的 Canary 部署。&lt;/p&gt;
&lt;p&gt;Kubernetes 能够提供以下一些功能：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://Crisescode.github.io/blog/categories/Kubernetes/"/>
    
    
      <category term="kubeadm" scheme="https://Crisescode.github.io/blog/tags/kubeadm/"/>
    
      <category term="k8s集群" scheme="https://Crisescode.github.io/blog/tags/k8s%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>[AI] 模型部署实践（1）Gunicorn + Falcon + Model</title>
    <link href="https://crisescode.github.io/blog/2020/08/31/NLP-%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%EF%BC%881%EF%BC%89Gunicorn-Falcon-Model/"/>
    <id>https://crisescode.github.io/blog/2020/08/31/NLP-%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%EF%BC%881%EF%BC%89Gunicorn-Falcon-Model/</id>
    <published>2020-08-31T15:05:49.000Z</published>
    <updated>2020-09-29T07:53:12.327Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="AI" scheme="https://Crisescode.github.io/blog/categories/AI/"/>
    
      <category term="模型部署" scheme="https://Crisescode.github.io/blog/categories/AI/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="HTTP 部署" scheme="https://Crisescode.github.io/blog/tags/HTTP-%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>[NLP] 文本摘要之PGN指针生成网络</title>
    <link href="https://crisescode.github.io/blog/2020/08/08/NLP-%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E4%B9%8BPGN%E6%8C%87%E9%92%88%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/"/>
    <id>https://crisescode.github.io/blog/2020/08/08/NLP-%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E4%B9%8BPGN%E6%8C%87%E9%92%88%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/</id>
    <published>2020-08-08T06:48:20.000Z</published>
    <updated>2020-08-08T06:57:39.622Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="NLP" scheme="https://Crisescode.github.io/blog/categories/NLP/"/>
    
      <category term="文本生成" scheme="https://Crisescode.github.io/blog/categories/NLP/%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90/"/>
    
    
      <category term="PGN" scheme="https://Crisescode.github.io/blog/tags/PGN/"/>
    
  </entry>
  
  <entry>
    <title>分布式训练之PyTorch</title>
    <link href="https://crisescode.github.io/blog/2020/07/31/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E4%B9%8BPyTorch/"/>
    <id>https://crisescode.github.io/blog/2020/07/31/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E4%B9%8BPyTorch/</id>
    <published>2020-07-31T13:09:48.000Z</published>
    <updated>2020-08-01T03:07:30.541Z</updated>
    
    <content type="html"><![CDATA[<p>由于近期来自客户需求，需要部门开发的AI平台支持上 PyTorch 框架的分布式训练，因此自己也是花了大概一周的时间，仔细研究了下 PyTorch 的分布式训练，中间也遇到了不少问题，好在通过查阅相关资料大都解决了，昨天也到客户那已经部署成功了。现将关于 PyTorch 分布式训练知识总结一下，方便大家或自己以后查阅，以下内容如有总结不到位的地方，请大家不吝赐教~</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于近期来自客户需求，需要部门开发的AI平台支持上 PyTorch 框架的分布式训练，因此自己也是花了大概一周的时间，仔细研究了下 PyTorch 的分布式训练，中间也遇到了不少问题，好在通过查阅相关资料大都解决了，昨天也到客户那已经部署成功了。现将关于 PyTorch 分
      
    
    </summary>
    
    
      <category term="深度学习框架" scheme="https://Crisescode.github.io/blog/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="分布式训练" scheme="https://Crisescode.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    
      <category term="DL" scheme="https://Crisescode.github.io/blog/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第十一天</title>
    <link href="https://crisescode.github.io/blog/2020/07/29/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/29/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9/</id>
    <published>2020-07-29T15:20:11.000Z</published>
    <updated>2020-07-31T13:25:55.097Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第十天</title>
    <link href="https://crisescode.github.io/blog/2020/07/27/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/27/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E5%A4%A9/</id>
    <published>2020-07-27T15:23:17.000Z</published>
    <updated>2020-07-31T13:25:54.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ29-最小的K个数"><a href="#JZ29-最小的K个数" class="headerlink" title="JZ29 最小的K个数"></a>JZ29 最小的K个数</h3><p><strong>题目描述：</strong></p><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p></blockquote><p><strong>解法思路：</strong><br>这题第一印象是直接将列表从小到大进行排序然后返回前K个数即可。所以本题第一种方法就是利用快排然后返回前K个数得到结果，这个方法没什么好说的，只要对快排熟悉即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def GetLeastNumbers_Solution(self, tinput, k):</span><br><span class="line">    # write code here</span><br><span class="line">    if tinput &#x3D;&#x3D; [] or k &lt;&#x3D; 0 or k &gt; len(tinput):</span><br><span class="line">        return []</span><br><span class="line"></span><br><span class="line">    return self.quick_sort(tinput)[:k]</span><br><span class="line"></span><br><span class="line">def quick_sort(self, array):</span><br><span class="line">    if len(array) &lt;&#x3D; 1:</span><br><span class="line">        return array</span><br><span class="line"></span><br><span class="line">    pivot &#x3D; array[0]</span><br><span class="line">    less_pivot &#x3D; [num for num in array if num &lt; pivot]</span><br><span class="line">    more_pivot &#x3D; [num for num in array if num &gt; pivot]</span><br><span class="line"></span><br><span class="line">    return self.quick_sort(less_pivot) + [pivot] + self.quick_sort(more_pivot)</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    array &#x3D; [4, 5, 1, 6, 2, 7, 3, 8]</span><br><span class="line">    print(Solution().GetLeastNumbers_Solution(array, 4))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JZ28-数组中出现次数超过一半的数字"><a href="#JZ28-数组中出现次数超过一半的数字" class="headerlink" title="JZ28 数组中出现次数超过一半的数字"></a>JZ28 数组中出现次数超过一半的数字</h3><p><strong>题目描述：</strong></p><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。<br>由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p></blockquote><p><strong>解法思路：</strong><br>很朴素的做法，利用哈希进行统计出数字出现的次数，然后再与数组的长度的一半进行比较即可得到结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def MoreThanHalfNum_Solution(self, numbers):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(numbers) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        length &#x3D; len(numbers)</span><br><span class="line">        hash_map &#x3D; &#123;&#125;</span><br><span class="line">        for num in numbers:</span><br><span class="line">            if num in hash_map:</span><br><span class="line">                hash_map[num] +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                hash_map[num] &#x3D; 1</span><br><span class="line">        nums &#x3D; [num for num in hash_map.keys() if hash_map[num] &gt; length &#x2F; 2]</span><br><span class="line">        return nums[0] if nums else 0</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    numbers &#x3D; [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">    print(Solution().MoreThanHalfNum_Solution(numbers))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure><h3 id="JZ30-连续子数组的最大和"><a href="#JZ30-连续子数组的最大和" class="headerlink" title="JZ30 连续子数组的最大和"></a>JZ30 连续子数组的最大和</h3><p><strong>题目描述：</strong></p><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,<br>当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？<br>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，<br>你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><p><strong>解法思路：</strong><br>动态规划方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def FindGreatestSumOfSubArray(self, array):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(array) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        max_num &#x3D; array[0]</span><br><span class="line">        continuous_sum &#x3D; 0</span><br><span class="line">        for num in array:</span><br><span class="line">            if continuous_sum &gt; 0:</span><br><span class="line">                continuous_sum +&#x3D; num</span><br><span class="line">            else:</span><br><span class="line">                continuous_sum &#x3D; num</span><br><span class="line">            max_num &#x3D; max(continuous_sum, max_num)</span><br><span class="line"></span><br><span class="line">        return max_num</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    array &#x3D; [6, -3, -2, 7, -15, 1, 2, 2]</span><br><span class="line">    print(Solution().FindGreatestSumOfSubArray(array))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 8</span><br></pre></td></tr></table></figure><h3 id="JZ50-数组中重复的数字"><a href="#JZ50-数组中重复的数字" class="headerlink" title="JZ50 数组中重复的数字"></a>JZ50 数组中重复的数字</h3><p><strong>题目描述：</strong></p><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。<br>请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span><br><span class="line">    # 函数返回True&#x2F;False</span><br><span class="line">    def duplicate(self, numbers, duplication):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(numbers) &#x3D;&#x3D; 0:</span><br><span class="line">            return False, 0</span><br><span class="line">        stack &#x3D; []</span><br><span class="line">        for num in numbers:</span><br><span class="line">            if num &gt; len(numbers) - 1:</span><br><span class="line">                return False, 0</span><br><span class="line">            if num not in stack:</span><br><span class="line">                stack.append(num)</span><br><span class="line">            else:</span><br><span class="line">               duplication.append(num)</span><br><span class="line">               return True, duplication[0]</span><br><span class="line"></span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    # numbers &#x3D; [2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">    numbers &#x3D; [2, 1, 3, 1, 4]</span><br><span class="line">    print(Solution().duplicate(numbers, []))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; (True, 1)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ29-最小的K个数&quot;&gt;&lt;a href=&quot;#JZ29-最小的K个数&quot; class=&quot;headerlink&quot; title=&quot;JZ29 最小的K个数&quot;&gt;&lt;/a&gt;JZ29 最小的K个数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;这题第一印象是直接将列表从小到大进行排序然后返回前K个数即可。所以本题第一种方法就是利用快排然后返回前K个数得到结果，这个方法没什么好说的，只要对快排熟悉即可。&lt;/p&gt;
&lt;!--�0--&gt;
&lt;p&gt;&lt;strong&gt;代码测试：&lt;/strong&gt;&lt;/p&gt;
&lt;!--�1--&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第九天</title>
    <link href="https://crisescode.github.io/blog/2020/07/25/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B9%9D%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/25/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B9%9D%E5%A4%A9/</id>
    <published>2020-07-25T14:05:00.000Z</published>
    <updated>2020-07-27T15:32:14.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ64-滑动窗口的最大值"><a href="#JZ64-滑动窗口的最大值" class="headerlink" title="JZ64 滑动窗口的最大值"></a>JZ64 滑动窗口的最大值</h3><p><strong>题目描述：</strong></p><blockquote><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，<br>{2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p></blockquote><p>这道题其实是昨天最后一道题<a href="http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/" target="_blank" rel="noopener"><code>JZ60</code></a>的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度<code>depth</code>进行解题。在每次需要打印的地方，当深度<code>depth</code>对2取余，为0则从左到右打印，为1则反转打印。</p><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxInWindows(self, num, size):</span><br><span class="line">        # write code here</span><br><span class="line">        if num is None or size &lt;&#x3D; 0:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        max_list &#x3D; []</span><br><span class="line">        for i in range(len(num) - size + 1):</span><br><span class="line">            range_ &#x3D; num[i: i+size]</span><br><span class="line">            max_list.append(max(range_))</span><br><span class="line">        return max_list</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().maxInWindows([2, 3, 4, 2, 6, 2, 5, 1], 2))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [3, 4, 4, 6, 6, 5, 5]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JZ40-数组中只出现一次的数字"><a href="#JZ40-数组中只出现一次的数字" class="headerlink" title="JZ40 数组中只出现一次的数字"></a>JZ40 数组中只出现一次的数字</h3><p><strong>题目描述：</strong></p><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p></blockquote><p><strong>解法思路：</strong></p><!--more--><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 返回[a,b] 其中ab是出现一次的两个数字</span><br><span class="line">    def FindNumsAppearOnce(self, array):</span><br><span class="line">        # write code here</span><br><span class="line">        if array is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        hash_map &#x3D; &#123;&#125;</span><br><span class="line">        for num in array:</span><br><span class="line">            if num in hash_map:</span><br><span class="line">                hash_map[num] +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                hash_map[num] &#x3D; 1</span><br><span class="line"></span><br><span class="line">        res &#x3D; [num for num in hash_map.keys() if hash_map[num] &#x3D;&#x3D; 1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().FindNumsAppearOnce([2, 3, 1, 5, 1, 3, 6, 11, 6, 0, 11, 5]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [2, 0]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ64-滑动窗口的最大值&quot;&gt;&lt;a href=&quot;#JZ64-滑动窗口的最大值&quot; class=&quot;headerlink&quot; title=&quot;JZ64 滑动窗口的最大值&quot;&gt;&lt;/a&gt;JZ64 滑动窗口的最大值&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：&lt;br&gt;{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，&lt;br&gt;{2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题其实是昨天最后一道题&lt;a href=&quot;http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;JZ60&lt;/code&gt;&lt;/a&gt;的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度&lt;code&gt;depth&lt;/code&gt;进行解题。在每次需要打印的地方，当深度&lt;code&gt;depth&lt;/code&gt;对2取余，为0则从左到右打印，为1则反转打印。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;/p&gt;
&lt;!--�64--&gt;
&lt;p&gt;&lt;strong&gt;代码测试：&lt;/strong&gt;&lt;/p&gt;
&lt;!--�65--&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第八天</title>
    <link href="https://crisescode.github.io/blog/2020/07/20/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AB%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/20/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AB%E5%A4%A9/</id>
    <published>2020-07-20T15:43:10.000Z</published>
    <updated>2020-07-27T15:53:18.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ59-按之字形顺序打印二叉树"><a href="#JZ59-按之字形顺序打印二叉树" class="headerlink" title="JZ59 按之字形顺序打印二叉树"></a>JZ59 按之字形顺序打印二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p></blockquote><p><strong>解法思路：</strong><br>这道题其实是昨天最后一道题<a href="http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/" target="_blank" rel="noopener"><code>JZ60</code></a>的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度<code>depth</code>进行解题。在每次需要打印的地方，当深度<code>depth</code>对2取余，为0则从左到右打印，为1则反转打印。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def Print(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot is None:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        depth &#x3D; 0</span><br><span class="line">        node_queue &#x3D; [pRoot]</span><br><span class="line">        res &#x3D; []</span><br><span class="line"></span><br><span class="line">        while node_queue:</span><br><span class="line">            val &#x3D; []</span><br><span class="line">            length &#x3D; len(node_queue)</span><br><span class="line">            for i in range(length):</span><br><span class="line">                current &#x3D; node_queue.pop(0)</span><br><span class="line">                val.append(current.val)</span><br><span class="line"></span><br><span class="line">                if current.left:</span><br><span class="line">                    node_queue.append(current.left)</span><br><span class="line"></span><br><span class="line">                if current.right:</span><br><span class="line">                    node_queue.append(current.right)</span><br><span class="line"></span><br><span class="line">            if depth % 2 &#x3D;&#x3D; 0:</span><br><span class="line">                res.append(val)</span><br><span class="line">            else:</span><br><span class="line">                res.append(list(reversed(val)))</span><br><span class="line"></span><br><span class="line">            depth +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().Print(root))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [[0], [2, 1], [3, 4, 5], [6]]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JZ58-对称的二叉树"><a href="#JZ58-对称的二叉树" class="headerlink" title="JZ58 对称的二叉树"></a>JZ58 对称的二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p></blockquote><p><strong>解法思路：</strong></p><!--more--><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Solution:</span><br><span class="line">    def isSymmetrical(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    num &#x3D; 1</span><br><span class="line">    matrix &#x3D; [[0 for i in range(4)] for j in range(4)]</span><br><span class="line">    for i in range(4):</span><br><span class="line">        for j in range(4):</span><br><span class="line">            matrix[i][j] &#x3D; num</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    print(Solution().printMatrix(matrix))</span><br><span class="line">    print(Solution().printMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]</span><br><span class="line">[1, 2, 4, 6, 8, 10, 9, 7, 5, 3]</span><br></pre></td></tr></table></figure><h3 id="JZ38-二叉树的下一个结点"><a href="#JZ38-二叉树的下一个结点" class="headerlink" title="JZ38 二叉树的下一个结点"></a>JZ38 二叉树的下一个结点</h3><p><strong>题目描述：</strong></p><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def GetNext(self, pNode):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="JZ38-平衡二叉树"><a href="#JZ38-平衡二叉树" class="headerlink" title="JZ38 平衡二叉树"></a>JZ38 平衡二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p></blockquote><blockquote><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def IsBalanced_Solution(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ59-按之字形顺序打印二叉树&quot;&gt;&lt;a href=&quot;#JZ59-按之字形顺序打印二叉树&quot; class=&quot;headerlink&quot; title=&quot;JZ59 按之字形顺序打印二叉树&quot;&gt;&lt;/a&gt;JZ59 按之字形顺序打印二叉树&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;这道题其实是昨天最后一道题&lt;a href=&quot;http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;JZ60&lt;/code&gt;&lt;/a&gt;的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度&lt;code&gt;depth&lt;/code&gt;进行解题。在每次需要打印的地方，当深度&lt;code&gt;depth&lt;/code&gt;对2取余，为0则从左到右打印，为1则反转打印。&lt;/p&gt;
&lt;!--�48--&gt;
&lt;p&gt;&lt;strong&gt;代码测试：&lt;/strong&gt;&lt;/p&gt;
&lt;!--�49--&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第七天</title>
    <link href="https://crisescode.github.io/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/</id>
    <published>2020-07-19T13:33:15.000Z</published>
    <updated>2020-07-20T15:47:40.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ19-顺时针打印矩阵"><a href="#JZ19-顺时针打印矩阵" class="headerlink" title="JZ19 顺时针打印矩阵"></a>JZ19 顺时针打印矩阵</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p></blockquote><p><strong>解法思路：</strong><br>这道题刚开始自己一看，就是想着设置一些索引位置，按照索引位置打印来打印不就行了。后来再认真读题，发现它输入的二维矩阵大小是变化的，不是固定大小，才发现自己的想法太<code>native</code>。</p><p>看了下讨论区，发现只是需要确定几个固定位置的索引值，便可以不管输入矩阵的大小，自适应的便能够确定顺时针打印每个位置的索引，然后再根据这个索引来打印矩阵就行，还真是巧妙。其实在确定好几个顶点的位置，也就相当于确定了方向，然后不管是顺时针还是逆时针，下次都可以方便的解题了。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # matrix类型为二维列表，需要返回列表</span><br><span class="line">    def printMatrix(self, matrix):</span><br><span class="line">        # write code here</span><br><span class="line">        top &#x3D; 0</span><br><span class="line">        bottom &#x3D; len(matrix)</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; len(matrix[0])</span><br><span class="line"></span><br><span class="line">        res &#x3D; []</span><br><span class="line">        # 判断是否越界</span><br><span class="line">        while top &lt; bottom and left &lt; right:</span><br><span class="line">            # 最上面一行，需向右打印</span><br><span class="line">            res.extend([matrix[top][c] for c in range(left, right)])</span><br><span class="line">            # 最右边一行，需向下打印</span><br><span class="line">            res.extend([matrix[r][right - 1] for r in range(top + 1, bottom)])</span><br><span class="line">            # 最下面一行，需向左打印</span><br><span class="line">            if bottom - top &gt; 1:</span><br><span class="line">                res.extend([matrix[bottom - 1][c] for c in range(right - 2, left, -1)]) # 注意需要将右边那个值去除掉</span><br><span class="line">            # 最左边一行，需向上打印</span><br><span class="line">            if right - left &gt; 1:</span><br><span class="line">                res.extend([matrix[r][left] for r in range(bottom - 1, top, -1)])</span><br><span class="line"></span><br><span class="line">            top +&#x3D; 1</span><br><span class="line">            bottom -&#x3D; 1</span><br><span class="line">            left +&#x3D; 1</span><br><span class="line">            right -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    num &#x3D; 1</span><br><span class="line">    matrix &#x3D; [[0 for i in range(4)] for j in range(4)]</span><br><span class="line">    for i in range(4):</span><br><span class="line">        for j in range(4):</span><br><span class="line">            matrix[i][j] &#x3D; num</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    print(Solution().printMatrix(matrix))</span><br><span class="line">    print(Solution().printMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]</span><br><span class="line">[1, 2, 4, 6, 8, 10, 9, 7, 5, 3]</span><br></pre></td></tr></table></figure><h3 id="JZ38-二叉树的深度"><a href="#JZ38-二叉树的深度" class="headerlink" title="JZ38 二叉树的深度"></a>JZ38 二叉树的深度</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        x &#x3D; pRoot</span><br><span class="line"></span><br><span class="line">        left &#x3D; self.TreeDepth(pRoot.left)</span><br><span class="line">        right &#x3D; self.TreeDepth(pRoot.right)</span><br><span class="line"></span><br><span class="line">        return max(left, right) + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution2:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot is None:</span><br><span class="line">            return 0</span><br><span class="line">        q &#x3D; []</span><br><span class="line">        depth &#x3D; 0</span><br><span class="line">        q.append(pRoot)</span><br><span class="line">        while len(q):  # 队列为空时说明没有下一层</span><br><span class="line">            length &#x3D; len(q)</span><br><span class="line">            for i in range(length):  # 遍历层的每个节点看是否有子节点有则加入</span><br><span class="line">                current &#x3D; q.pop(0)  # current为当前遍历到的层中节点，取出，注意pop(-1)为默认，这里要pop(0),取出第一个，先入先出</span><br><span class="line">                if current.left:</span><br><span class="line">                    q.append(current.left)</span><br><span class="line">                if current.right:</span><br><span class="line">                    q.append(current.right)</span><br><span class="line">            depth +&#x3D; 1</span><br><span class="line">        return depth</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="JZ60-把二叉树打印成多行"><a href="#JZ60-把二叉树打印成多行" class="headerlink" title="JZ60 把二叉树打印成多行"></a>JZ60 把二叉树打印成多行</h3><p><strong>题目描述：</strong></p><blockquote><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回二维列表[[1,2],[4,5]]</span><br><span class="line">    def Print(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        node_queue &#x3D; [pRoot]</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while node_queue:</span><br><span class="line">            val &#x3D; []</span><br><span class="line">            length &#x3D; len(node_queue)</span><br><span class="line">            for i in range(length):</span><br><span class="line">                current &#x3D; node_queue.pop(0)</span><br><span class="line">                val.append(current.val)</span><br><span class="line"></span><br><span class="line">                if current.left:</span><br><span class="line">                    node_queue.append(current.left)</span><br><span class="line">                if current.right:</span><br><span class="line">                    node_queue.append(current.right)</span><br><span class="line"></span><br><span class="line">            res.append(val)</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(8)</span><br><span class="line">    root.left &#x3D; TreeNode(6)</span><br><span class="line">    root.right &#x3D; TreeNode(10)</span><br><span class="line">    root.left.left &#x3D; TreeNode(5)</span><br><span class="line">    root.left.right &#x3D; TreeNode(7)</span><br><span class="line">    root.right.left &#x3D; TreeNode(9)</span><br><span class="line">    root.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    print(Solution().Print(root))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [[8], [6, 10], [5, 7, 9, 11]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ19-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#JZ19-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;JZ19 顺时针打印矩阵&quot;&gt;&lt;/a&gt;JZ19 顺时针打印矩阵&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;这道题刚开始自己一看，就是想着设置一些索引位置，按照索引位置打印来打印不就行了。后来再认真读题，发现它输入的二维矩阵大小是变化的，不是固定大小，才发现自己的想法太&lt;code&gt;native&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;看了下讨论区，发现只是需要确定几个固定位置的索引值，便可以不管输入矩阵的大小，自适应的便能够确定顺时针打印每个位置的索引，然后再根据这个索引来打印矩阵就行，还真是巧妙。其实在确定好几个顶点的位置，也就相当于确定了方向，然后不管是顺时针还是逆时针，下次都可以方便的解题了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第六天</title>
    <link href="https://crisescode.github.io/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AD%E5%A4%A9/</id>
    <published>2020-07-13T12:43:55.000Z</published>
    <updated>2020-07-19T14:34:09.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ6-旋转数组的最小数字"><a href="#JZ6-旋转数组的最小数字" class="headerlink" title="JZ6 旋转数组的最小数字"></a>JZ6 旋转数组的最小数字</h3><p><strong>题目描述：</strong></p><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p><strong>解法思路：</strong><br>这题主要是考察二分查找。<strong>二分查找</strong>，又叫折半查找。它的前提是线性表中的数据必须是有序的，线性表必须采用顺序存储。主要思想是：在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找；不断重复上述过程，直至查找成功，或所有查找区域无记录，查找失败为止。</p><p>上面介绍了二分查找的主要思路，而本题难点在于找到中间值与谁进行比较？ 再认真审下题，给定的是非递减排序的数组，也就是“平序”或升序。例如：<code>[1, 2, 3, 3, 3, 5, 6]</code>（“平序”），<code>[1, 2, 3, 4, 5, 6]</code>（升序）。然后再做旋转得到旋转数组<code>[3, 3, 5, 6, 1, 2, 3]</code>，<code>[4, 5, 6, 1, 2, 3]</code>，可以确定的是旋转后的数组<code>nums[0] &gt;= nums[-1]</code>恒成立。</p><p>这样也就得到了<code>nums[mid]</code>与哪个值进行比较了，当然是：</p><ul><li><code>nums[mid] &gt; nums[left]</code> , 这个时候 <code>left = mid + 1</code></li><li><code>nums[mid] &lt; nums[right]</code>, 这个时候 <code>right = mid</code></li><li><code>nums[mid] = nums[right]</code>, 这个时候 <code>left += 1</code></li></ul><p>这里可以一定意义上认为<code>nums[left]</code>与<code>nums[right]</code>近似相等，这样便于理解。</p><blockquote><p>注: 以上<code>nums</code>代表传入的旋转数组，<code>left</code>指数组的第一个数，<code>right</code>指数组末尾的数，<code>mid</code>指数组中间位置的数。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(rotateArray) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; len(rotateArray) - 1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            if rotateArray[left] &lt; rotateArray[right]:</span><br><span class="line">                return rotateArray[left]</span><br><span class="line"></span><br><span class="line">            mid &#x3D; (left + right) &#x2F;&#x2F; 2</span><br><span class="line">            if rotateArray[mid] &gt; rotateArray[left]:</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            elif rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">            else:</span><br><span class="line">                left +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return rotateArray[left]</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().minNumberInRotateArray([1, 0, 1, 1, 1]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure><h3 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h3><p><strong>题目描述：</strong></p><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br> 二叉树的镜像定义如下：</p></blockquote><pre><code> 源二叉树    8   /  \  6   10 / \  / \5  7 9 11镜像二叉树     8   /  \  10   6 / \  / \11 9 7  5</code></pre><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回镜像树的根节点</span><br><span class="line">    def Mirror(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        root.left, root.right &#x3D; \</span><br><span class="line">            self.Mirror(root.right), self.Mirror(root.left)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    tree1 &#x3D; TreeNode(8)</span><br><span class="line">    tree1.left &#x3D; TreeNode(6)</span><br><span class="line">    tree1.right &#x3D; TreeNode(10)</span><br><span class="line">    tree1.left.left &#x3D; TreeNode(5)</span><br><span class="line">    tree1.left.right &#x3D; TreeNode(7)</span><br><span class="line">    tree1.right.left &#x3D; TreeNode(9)</span><br><span class="line">    tree1.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    invert_tree &#x3D; Solution().Mirror(tree1)</span><br><span class="line">    print(Solution().preOrder(invert_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 8 10 11 9 6 7 5 None</span><br></pre></td></tr></table></figure><h3 id="JZ23-二叉搜索树的后序遍历"><a href="#JZ23-二叉搜索树的后序遍历" class="headerlink" title="JZ23 二叉搜索树的后序遍历"></a>JZ23 二叉搜索树的后序遍历</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(sequence) &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        root &#x3D; sequence[-1]</span><br><span class="line">        for index, value in enumerate(sequence):</span><br><span class="line">            if value &gt; root:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for value in sequence[index: -1]:</span><br><span class="line">            if value &lt; root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">        left &#x3D; True</span><br><span class="line">        if index &gt; 0:</span><br><span class="line">            left &#x3D; self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line"></span><br><span class="line">        right &#x3D; True</span><br><span class="line">        if index &lt; len(sequence) - 1:</span><br><span class="line">            right &#x3D; self.VerifySquenceOfBST(sequence[index: -1])</span><br><span class="line"></span><br><span class="line">        return left and right</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    is_binary_tree &#x3D; [1, 3, 5, 9, 12, 10, 7]</span><br><span class="line">    print(Solution().VerifySquenceOfBST(is_binary_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><h3 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h3><p><strong>题目描述：</strong></p><blockquote><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><blockquote><p>输入：8<br>输出：18 </p></blockquote><p><strong>解法思路：</strong></p><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ6-旋转数组的最小数字&quot;&gt;&lt;a href=&quot;#JZ6-旋转数组的最小数字&quot; class=&quot;headerlink&quot; title=&quot;JZ6 旋转数组的最小数字&quot;&gt;&lt;/a&gt;JZ6 旋转数组的最小数字&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。&lt;br&gt;输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。&lt;br&gt;例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。&lt;br&gt;NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;这题主要是考察二分查找。&lt;strong&gt;二分查找&lt;/strong&gt;，又叫折半查找。它的前提是线性表中的数据必须是有序的，线性表必须采用顺序存储。主要思想是：在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找；不断重复上述过程，直至查找成功，或所有查找区域无记录，查找失败为止。&lt;/p&gt;
&lt;p&gt;上面介绍了二分查找的主要思路，而本题难点在于找到中间值与谁进行比较？ 再认真审下题，给定的是非递减排序的数组，也就是“平序”或升序。例如：&lt;code&gt;[1, 2, 3, 3, 3, 5, 6]&lt;/code&gt;（“平序”），&lt;code&gt;[1, 2, 3, 4, 5, 6]&lt;/code&gt;（升序）。然后再做旋转得到旋转数组&lt;code&gt;[3, 3, 5, 6, 1, 2, 3]&lt;/code&gt;，&lt;code&gt;[4, 5, 6, 1, 2, 3]&lt;/code&gt;，可以确定的是旋转后的数组&lt;code&gt;nums[0] &amp;gt;= nums[-1]&lt;/code&gt;恒成立。&lt;/p&gt;
&lt;p&gt;这样也就得到了&lt;code&gt;nums[mid]&lt;/code&gt;与哪个值进行比较了，当然是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums[mid] &amp;gt; nums[left]&lt;/code&gt; , 这个时候 &lt;code&gt;left = mid + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[mid] &amp;lt; nums[right]&lt;/code&gt;, 这个时候 &lt;code&gt;right = mid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[mid] = nums[right]&lt;/code&gt;, 这个时候 &lt;code&gt;left += 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里可以一定意义上认为&lt;code&gt;nums[left]&lt;/code&gt;与&lt;code&gt;nums[right]&lt;/code&gt;近似相等，这样便于理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注: 以上&lt;code&gt;nums&lt;/code&gt;代表传入的旋转数组，&lt;code&gt;left&lt;/code&gt;指数组的第一个数，&lt;code&gt;right&lt;/code&gt;指数组末尾的数，&lt;code&gt;mid&lt;/code&gt;指数组中间位置的数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第五天</title>
    <link href="https://crisescode.github.io/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E5%A4%A9/</id>
    <published>2020-07-13T12:43:35.000Z</published>
    <updated>2020-07-19T15:03:18.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ8-跳台阶"><a href="#JZ8-跳台阶" class="headerlink" title="JZ8 跳台阶"></a>JZ8 跳台阶</h3><p><strong>题目描述：</strong></p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><p><strong>解法思路：</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        res, counter &#x3D; 1, 0</span><br><span class="line">        for i in range(1, number + 1):</span><br><span class="line">            res &#x3D; res + counter</span><br><span class="line">            counter &#x3D; res - counter</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().jumpFloor(3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3</span><br></pre></td></tr></table></figure><h3 id="JZ9-变态跳台阶"><a href="#JZ9-变态跳台阶" class="headerlink" title="JZ9 变态跳台阶"></a>JZ9 变态跳台阶</h3><p><strong>题目描述：</strong></p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        curr, prev &#x3D; 1, 1</span><br><span class="line">        for i in range(1, number):</span><br><span class="line">            curr &#x3D; 2 * prev</span><br><span class="line">            prev &#x3D; curr</span><br><span class="line"></span><br><span class="line">        return curr</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().jumpFloor(3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 4</span><br></pre></td></tr></table></figure><h3 id="JZ10-矩形覆盖"><a href="#JZ10-矩形覆盖" class="headerlink" title="JZ10 矩形覆盖"></a>JZ10 矩形覆盖</h3><p><strong>题目描述：</strong></p><blockquote><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rectCover(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        res, counter &#x3D; 1, 0</span><br><span class="line">        for i in range(1, number + 1):</span><br><span class="line">            res &#x3D; res + counter</span><br><span class="line">            counter &#x3D; res - counter</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().rectCover(4))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 5</span><br></pre></td></tr></table></figure><h3 id="JZ21-栈的压入、弹出序列"><a href="#JZ21-栈的压入、弹出序列" class="headerlink" title="JZ21 栈的压入、弹出序列"></a>JZ21 栈的压入、弹出序列</h3><p><strong>题目描述：</strong></p><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。<br>（注意：这两个序列的长度是相等的）</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def IsPopOrder(self, pushV, popV):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ8-跳台阶&quot;&gt;&lt;a href=&quot;#JZ8-跳台阶&quot; class=&quot;headerlink&quot; title=&quot;JZ8 跳台阶&quot;&gt;&lt;/a&gt;JZ8 跳台阶&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第四天</title>
    <link href="https://crisescode.github.io/blog/2020/07/11/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/11/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%9B%9B%E5%A4%A9/</id>
    <published>2020-07-11T15:10:27.000Z</published>
    <updated>2020-07-11T15:50:48.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ4-重建二叉树"><a href="#JZ4-重建二叉树" class="headerlink" title="JZ4 重建二叉树"></a>JZ4 重建二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 [1,2,4,7,3,5,6,8] 和中序遍历序列 [4,7,2,1,5,3,8,6] ，则重建二叉树并返回。</p></blockquote><p><strong>解法思路：</strong><br>使用递归的方法求解。这道题需要对二叉树的性质比较了解，需要熟悉二叉树的几种遍历方式。</p><p><strong>前序遍历是先遍历根节点，然后遍历左节点，最后遍历右节点（根左右）</strong></p><p><strong>中序遍历是先遍历左节点，然后遍历根节点，最后遍历右节点（左根右）</strong></p><p><strong>后序遍历是先遍历左节点，然后遍历右节点，最后遍历根节点（根左右）</strong></p><p>本题给定前序遍历以及中序遍历的序列，可以知道前序遍历第一个值一定是根节点。而根节点在中序遍历中会把左右子树分成两半。因此本题的关键是找到根节点，然后将左右子树依次递归重建得到二叉树。</p><p>使用递归是需要结束条件的，当前序或中序遍历序列为<code>None</code>时，便可推出递归，得到二叉树。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        if not pre or not tin:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        root &#x3D; TreeNode(pre.pop(0))</span><br><span class="line">        index &#x3D; tin.index(root.val)</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; self.reConstructBinaryTree(pre, tin[:index])</span><br><span class="line">        root.right &#x3D; self.reConstructBinaryTree(pre, tin[index + 1:])</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br><span class="line"></span><br><span class="line">    def InOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line">        self.InOrder(root.left)</span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.InOrder(root.right)</span><br><span class="line"></span><br><span class="line">    def BackOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line">        self.BackOrder(root.left)</span><br><span class="line">        self.BackOrder(root.right)</span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br></pre></td></tr></table></figure><p>本题只需写好<code>reConstructBinaryTree</code>这个方法，上面代码其他三个函数是用来前序、中序以及后序遍历重建得到二叉树的，以方便大家调试。<br><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    pre &#x3D; [1, 2, 4, 7, 3, 5, 6, 8]</span><br><span class="line">    tin &#x3D; [4, 7, 2, 1, 5, 3, 8, 6]</span><br><span class="line"></span><br><span class="line">    reTree &#x3D; Solution().reConstructBinaryTree(pre, tin)</span><br><span class="line">    print(&quot;前序遍历：&quot;)</span><br><span class="line">    Solution().preOrder(reTree)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    print(&quot;中序遍历：&quot;)</span><br><span class="line">    Solution().InOrder(reTree)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    print(&quot;后序遍历：&quot;)</span><br><span class="line">    Solution().BackOrder(reTree)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 前序遍历：</span><br><span class="line">1 2 4 7 3 5 6 8 </span><br><span class="line"></span><br><span class="line">中序遍历：</span><br><span class="line">4 7 2 1 5 3 8 6 </span><br><span class="line"></span><br><span class="line">后序遍历：</span><br><span class="line">7 4 2 5 8 6 3 1</span><br></pre></td></tr></table></figure><h3 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h3><p><strong>题目描述：</strong></p><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br> 二叉树的镜像定义如下：</p></blockquote><pre><code> 源二叉树    8   /  \  6   10 / \  / \5  7 9 11镜像二叉树     8   /  \  10   6 / \  / \11 9 7  5</code></pre><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回镜像树的根节点</span><br><span class="line">    def Mirror(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        root.left, root.right &#x3D; \</span><br><span class="line">            self.Mirror(root.right), self.Mirror(root.left)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    tree1 &#x3D; TreeNode(8)</span><br><span class="line">    tree1.left &#x3D; TreeNode(6)</span><br><span class="line">    tree1.right &#x3D; TreeNode(10)</span><br><span class="line">    tree1.left.left &#x3D; TreeNode(5)</span><br><span class="line">    tree1.left.right &#x3D; TreeNode(7)</span><br><span class="line">    tree1.right.left &#x3D; TreeNode(9)</span><br><span class="line">    tree1.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    invert_tree &#x3D; Solution().Mirror(tree1)</span><br><span class="line">    print(Solution().preOrder(invert_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 8 10 11 9 6 7 5 None</span><br></pre></td></tr></table></figure><h3 id="JZ23-二叉搜索树的后序遍历"><a href="#JZ23-二叉搜索树的后序遍历" class="headerlink" title="JZ23 二叉搜索树的后序遍历"></a>JZ23 二叉搜索树的后序遍历</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(sequence) &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        root &#x3D; sequence[-1]</span><br><span class="line">        for index, value in enumerate(sequence):</span><br><span class="line">            if value &gt; root:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for value in sequence[index: -1]:</span><br><span class="line">            if value &lt; root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">        left &#x3D; True</span><br><span class="line">        if index &gt; 0:</span><br><span class="line">            left &#x3D; self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line"></span><br><span class="line">        right &#x3D; True</span><br><span class="line">        if index &lt; len(sequence) - 1:</span><br><span class="line">            right &#x3D; self.VerifySquenceOfBST(sequence[index: -1])</span><br><span class="line"></span><br><span class="line">        return left and right</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    is_binary_tree &#x3D; [1, 3, 5, 9, 12, 10, 7]</span><br><span class="line">    print(Solution().VerifySquenceOfBST(is_binary_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><h3 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h3><p><strong>题目描述：</strong></p><blockquote><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><blockquote><p>输入：8<br>输出：18 </p></blockquote><p><strong>解法思路：</strong></p><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ4-重建二叉树&quot;&gt;&lt;a href=&quot;#JZ4-重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;JZ4 重建二叉树&quot;&gt;&lt;/a&gt;JZ4 重建二叉树&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 [1,2,4,7,3,5,6,8] 和中序遍历序列 [4,7,2,1,5,3,8,6] ，则重建二叉树并返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;使用递归的方法求解。这道题需要对二叉树的性质比较了解，需要熟悉二叉树的几种遍历方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序遍历是先遍历根节点，然后遍历左节点，最后遍历右节点（根左右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序遍历是先遍历左节点，然后遍历根节点，最后遍历右节点（左根右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后序遍历是先遍历左节点，然后遍历右节点，最后遍历根节点（根左右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本题给定前序遍历以及中序遍历的序列，可以知道前序遍历第一个值一定是根节点。而根节点在中序遍历中会把左右子树分成两半。因此本题的关键是找到根节点，然后将左右子树依次递归重建得到二叉树。&lt;/p&gt;
&lt;p&gt;使用递归是需要结束条件的，当前序或中序遍历序列为&lt;code&gt;None&lt;/code&gt;时，便可推出递归，得到二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第三天</title>
    <link href="https://crisescode.github.io/blog/2020/07/08/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/08/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%89%E5%A4%A9/</id>
    <published>2020-07-08T14:33:32.000Z</published>
    <updated>2020-07-11T15:58:13.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ11-二进制中1的个数"><a href="#JZ11-二进制中1的个数" class="headerlink" title="JZ11 二进制中1的个数"></a>JZ11 二进制中1的个数</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p></blockquote><p><strong>解法思路：</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def NumberOf1(self, n):</span><br><span class="line">    # write code here</span><br><span class="line">    count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    if n &lt; 0:</span><br><span class="line">        n &#x3D; n &amp; 0b11111111111111111111111111111111</span><br><span class="line"></span><br><span class="line">    while n !&#x3D; 0:</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        n &#x3D; n &amp; (n - 1)</span><br><span class="line"></span><br><span class="line">    return count</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().NumberOf1(-11))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 30</span><br></pre></td></tr></table></figure><h3 id="JZ27-字符串的排列"><a href="#JZ27-字符串的排列" class="headerlink" title="JZ27 字符串的排列"></a>JZ27 字符串的排列</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p></blockquote><blockquote><p>输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Permutation(self, ss):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JZ47-求1-2-3-…-n"><a href="#JZ47-求1-2-3-…-n" class="headerlink" title="JZ47 求1 + 2 + 3 + … + n"></a>JZ47 求1 + 2 + 3 + … + n</h3><p><strong>题目描述：</strong></p><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; n</span><br><span class="line">        try:</span><br><span class="line">            res % n</span><br><span class="line">            res +&#x3D; self.Sum_Solution(n - 1)</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution2:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; n</span><br><span class="line">        tmp &#x3D; (res and self.Sum_Solution(n - 1))</span><br><span class="line">        res +&#x3D; tmp</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Sum_Solution(5))</span><br><span class="line">    print(Solution2().Sum_Solution(6))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 15</span><br><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="JZ51-构建乘积数组"><a href="#JZ51-构建乘积数组" class="headerlink" title="JZ51 构建乘积数组"></a>JZ51 构建乘积数组</h3><p><strong>题目描述：</strong></p><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def multiply(self, A):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ11-二进制中1的个数&quot;&gt;&lt;a href=&quot;#JZ11-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;JZ11 二进制中1的个数&quot;&gt;&lt;/a&gt;JZ11 二进制中1的个数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第二天</title>
    <link href="https://crisescode.github.io/blog/2020/07/07/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/07/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E5%A4%A9/</id>
    <published>2020-07-07T14:37:49.000Z</published>
    <updated>2020-07-07T15:07:56.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ49-把字符串转化成整数"><a href="#JZ49-把字符串转化成整数" class="headerlink" title="JZ49 把字符串转化成整数"></a>JZ49 把字符串转化成整数</h3><p><strong>题目描述：</strong></p><blockquote><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入描述：<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述：<br>如果是合法的数值表达则返回该数字，否则返回0</p></blockquote><blockquote><p>示例：<br>输入：<br>+2147483647<br>1a33<br>输出：<br>2147483647<br>0</p></blockquote><p><strong>解法思路：</strong><br>使用了一个很巧妙的方法，用一个字典将字符串”0”-“9”与数字0 - 9做一个映射，然后再用数学上计算一个数字的公式得出这个数。比如：<code>123 = (1 * 10 + 2 ) * 10 + 3</code>。需要注意字符串开头的正负号，从而判断得到的数字是整数还是负数。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def StrToInt(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(s) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        str2num &#x3D; &#123;</span><br><span class="line">            &quot;0&quot;: 0, &quot;1&quot;: 1, &quot;2&quot;: 2, &quot;3&quot;: 3, &quot;4&quot;: 4,</span><br><span class="line">            &quot;5&quot;: 5, &quot;6&quot;: 6, &quot;7&quot;: 7, &quot;8&quot;: 8, &quot;9&quot;: 9,</span><br><span class="line">            &quot;+&quot;: 1, &quot;-&quot;: -1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum &#x3D; 0</span><br><span class="line">        sign &#x3D; 1</span><br><span class="line">        for c in s:</span><br><span class="line">            if c in str2num:</span><br><span class="line">                if c &#x3D;&#x3D; &quot;+&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;+&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                if c &#x3D;&#x3D; &quot;-&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;-&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                sum &#x3D; sum * 10 + str2num[c]</span><br><span class="line">            else:</span><br><span class="line">                sum &#x3D; 0</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return sum * sign</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    s &#x3D; &quot;-98210&quot;</span><br><span class="line">    print(Solution().StrToInt(s))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 98210</span><br></pre></td></tr></table></figure><h3 id="JZ7-斐波那契数列"><a href="#JZ7-斐波那契数列" class="headerlink" title="JZ7 斐波那契数列"></a>JZ7 斐波那契数列</h3><p><strong>题目描述：</strong></p><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）(n&lt;=39)。</p></blockquote><p><strong>解法一思路：</strong><br>直接根据数学公式<code>f(n) = f(n - 1) + f(n - 2)</code>，截至条件是当<code>n = 1, f(n) = 1</code>，<code>n = 0, f(0) = 0</code>。利用<strong>递归法</strong>进行求解，这种方法时间复杂度很大，为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line">        else:</span><br><span class="line">            return self.Fibonacci(n-1) + self.Fibonacci(n-2)</span><br></pre></td></tr></table></figure><p><strong>解法二思路：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        n1, n2, n3 &#x3D; 0, 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            n3 &#x3D; n1 + n2</span><br><span class="line">            n1 &#x3D; n2</span><br><span class="line">            n2 &#x3D; n3</span><br><span class="line"></span><br><span class="line">        return n3</span><br></pre></td></tr></table></figure><p><strong>解法三思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution3:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        sum, one &#x3D; 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            sum &#x3D; sum + one</span><br><span class="line">            one &#x3D; sum - one</span><br><span class="line"></span><br><span class="line">        return sum</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Fibonacci(8))</span><br><span class="line">    print(Solution2().Fibonacci(8))</span><br><span class="line">    print(Solution3().Fibonacci(8))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br></pre></td></tr></table></figure><h3 id="JZ48-不用加减乘除做加法"><a href="#JZ48-不用加减乘除做加法" class="headerlink" title="JZ48 不用加减乘除做加法"></a>JZ48 不用加减乘除做加法</h3><p><strong>题目描述：</strong></p><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Add(self, num1, num2):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ49-把字符串转化成整数&quot;&gt;&lt;a href=&quot;#JZ49-把字符串转化成整数&quot; class=&quot;headerlink&quot; title=&quot;JZ49 把字符串转化成整数&quot;&gt;&lt;/a&gt;JZ49 把字符串转化成整数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0&lt;br&gt;输入描述：&lt;br&gt;输入一个字符串,包括数字字母符号,可以为空&lt;br&gt;输出描述：&lt;br&gt;如果是合法的数值表达则返回该数字，否则返回0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;示例：&lt;br&gt;输入：&lt;br&gt;+2147483647&lt;br&gt;1a33&lt;br&gt;输出：&lt;br&gt;2147483647&lt;br&gt;0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;使用了一个很巧妙的方法，用一个字典将字符串”0”-“9”与数字0 - 9做一个映射，然后再用数学上计算一个数字的公式得出这个数。比如：&lt;code&gt;123 = (1 * 10 + 2 ) * 10 + 3&lt;/code&gt;。需要注意字符串开头的正负号，从而判断得到的数字是整数还是负数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
