<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuckyCrise</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://crisescode.github.io/blog/"/>
  <updated>2020-08-08T06:57:39.622Z</updated>
  <id>https://crisescode.github.io/blog/</id>
  
  <author>
    <name>Crise</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[NLP] 文本摘要之PGN指针生成网络</title>
    <link href="https://crisescode.github.io/blog/2020/08/08/NLP-%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E4%B9%8BPGN%E6%8C%87%E9%92%88%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/"/>
    <id>https://crisescode.github.io/blog/2020/08/08/NLP-%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E4%B9%8BPGN%E6%8C%87%E9%92%88%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/</id>
    <published>2020-08-08T06:48:20.000Z</published>
    <updated>2020-08-08T06:57:39.622Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="NLP" scheme="https://Crisescode.github.io/blog/categories/NLP/"/>
    
      <category term="文本生成" scheme="https://Crisescode.github.io/blog/categories/NLP/%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90/"/>
    
    
      <category term="PGN" scheme="https://Crisescode.github.io/blog/tags/PGN/"/>
    
  </entry>
  
  <entry>
    <title>分布式训练之PyTorch</title>
    <link href="https://crisescode.github.io/blog/2020/07/31/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E4%B9%8BPyTorch/"/>
    <id>https://crisescode.github.io/blog/2020/07/31/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E4%B9%8BPyTorch/</id>
    <published>2020-07-31T13:09:48.000Z</published>
    <updated>2020-08-01T03:07:30.541Z</updated>
    
    <content type="html"><![CDATA[<p>由于近期来自客户需求，需要部门开发的AI平台支持上 PyTorch 框架的分布式训练，因此自己也是花了大概一周的时间，仔细研究了下 PyTorch 的分布式训练，中间也遇到了不少问题，好在通过查阅相关资料大都解决了，昨天也到客户那已经部署成功了。现将关于 PyTorch 分布式训练知识总结一下，方便大家或自己以后查阅，以下内容如有总结不到位的地方，请大家不吝赐教~</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于近期来自客户需求，需要部门开发的AI平台支持上 PyTorch 框架的分布式训练，因此自己也是花了大概一周的时间，仔细研究了下 PyTorch 的分布式训练，中间也遇到了不少问题，好在通过查阅相关资料大都解决了，昨天也到客户那已经部署成功了。现将关于 PyTorch 分
      
    
    </summary>
    
    
      <category term="深度学习框架" scheme="https://Crisescode.github.io/blog/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="分布式训练" scheme="https://Crisescode.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    
      <category term="DL" scheme="https://Crisescode.github.io/blog/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第十一天</title>
    <link href="https://crisescode.github.io/blog/2020/07/29/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/29/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9/</id>
    <published>2020-07-29T15:20:11.000Z</published>
    <updated>2020-07-31T13:25:55.097Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第十天</title>
    <link href="https://crisescode.github.io/blog/2020/07/27/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/27/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E5%A4%A9/</id>
    <published>2020-07-27T15:23:17.000Z</published>
    <updated>2020-07-31T13:25:54.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ29-最小的K个数"><a href="#JZ29-最小的K个数" class="headerlink" title="JZ29 最小的K个数"></a>JZ29 最小的K个数</h3><p><strong>题目描述：</strong></p><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p></blockquote><p><strong>解法思路：</strong><br>这题第一印象是直接将列表从小到大进行排序然后返回前K个数即可。所以本题第一种方法就是利用快排然后返回前K个数得到结果，这个方法没什么好说的，只要对快排熟悉即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def GetLeastNumbers_Solution(self, tinput, k):</span><br><span class="line">    # write code here</span><br><span class="line">    if tinput &#x3D;&#x3D; [] or k &lt;&#x3D; 0 or k &gt; len(tinput):</span><br><span class="line">        return []</span><br><span class="line"></span><br><span class="line">    return self.quick_sort(tinput)[:k]</span><br><span class="line"></span><br><span class="line">def quick_sort(self, array):</span><br><span class="line">    if len(array) &lt;&#x3D; 1:</span><br><span class="line">        return array</span><br><span class="line"></span><br><span class="line">    pivot &#x3D; array[0]</span><br><span class="line">    less_pivot &#x3D; [num for num in array if num &lt; pivot]</span><br><span class="line">    more_pivot &#x3D; [num for num in array if num &gt; pivot]</span><br><span class="line"></span><br><span class="line">    return self.quick_sort(less_pivot) + [pivot] + self.quick_sort(more_pivot)</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    array &#x3D; [4, 5, 1, 6, 2, 7, 3, 8]</span><br><span class="line">    print(Solution().GetLeastNumbers_Solution(array, 4))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JZ28-数组中出现次数超过一半的数字"><a href="#JZ28-数组中出现次数超过一半的数字" class="headerlink" title="JZ28 数组中出现次数超过一半的数字"></a>JZ28 数组中出现次数超过一半的数字</h3><p><strong>题目描述：</strong></p><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。<br>由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p></blockquote><p><strong>解法思路：</strong><br>很朴素的做法，利用哈希进行统计出数字出现的次数，然后再与数组的长度的一半进行比较即可得到结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def MoreThanHalfNum_Solution(self, numbers):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(numbers) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        length &#x3D; len(numbers)</span><br><span class="line">        hash_map &#x3D; &#123;&#125;</span><br><span class="line">        for num in numbers:</span><br><span class="line">            if num in hash_map:</span><br><span class="line">                hash_map[num] +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                hash_map[num] &#x3D; 1</span><br><span class="line">        nums &#x3D; [num for num in hash_map.keys() if hash_map[num] &gt; length &#x2F; 2]</span><br><span class="line">        return nums[0] if nums else 0</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    numbers &#x3D; [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">    print(Solution().MoreThanHalfNum_Solution(numbers))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure><h3 id="JZ30-连续子数组的最大和"><a href="#JZ30-连续子数组的最大和" class="headerlink" title="JZ30 连续子数组的最大和"></a>JZ30 连续子数组的最大和</h3><p><strong>题目描述：</strong></p><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,<br>当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？<br>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，<br>你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><p><strong>解法思路：</strong><br>动态规划方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def FindGreatestSumOfSubArray(self, array):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(array) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        max_num &#x3D; array[0]</span><br><span class="line">        continuous_sum &#x3D; 0</span><br><span class="line">        for num in array:</span><br><span class="line">            if continuous_sum &gt; 0:</span><br><span class="line">                continuous_sum +&#x3D; num</span><br><span class="line">            else:</span><br><span class="line">                continuous_sum &#x3D; num</span><br><span class="line">            max_num &#x3D; max(continuous_sum, max_num)</span><br><span class="line"></span><br><span class="line">        return max_num</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    array &#x3D; [6, -3, -2, 7, -15, 1, 2, 2]</span><br><span class="line">    print(Solution().FindGreatestSumOfSubArray(array))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 8</span><br></pre></td></tr></table></figure><h3 id="JZ50-数组中重复的数字"><a href="#JZ50-数组中重复的数字" class="headerlink" title="JZ50 数组中重复的数字"></a>JZ50 数组中重复的数字</h3><p><strong>题目描述：</strong></p><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。<br>请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span><br><span class="line">    # 函数返回True&#x2F;False</span><br><span class="line">    def duplicate(self, numbers, duplication):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(numbers) &#x3D;&#x3D; 0:</span><br><span class="line">            return False, 0</span><br><span class="line">        stack &#x3D; []</span><br><span class="line">        for num in numbers:</span><br><span class="line">            if num &gt; len(numbers) - 1:</span><br><span class="line">                return False, 0</span><br><span class="line">            if num not in stack:</span><br><span class="line">                stack.append(num)</span><br><span class="line">            else:</span><br><span class="line">               duplication.append(num)</span><br><span class="line">               return True, duplication[0]</span><br><span class="line"></span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    # numbers &#x3D; [2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">    numbers &#x3D; [2, 1, 3, 1, 4]</span><br><span class="line">    print(Solution().duplicate(numbers, []))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; (True, 1)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ29-最小的K个数&quot;&gt;&lt;a href=&quot;#JZ29-最小的K个数&quot; class=&quot;headerlink&quot; title=&quot;JZ29 最小的K个数&quot;&gt;&lt;/a&gt;JZ29 最小的K个数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;这题第一印象是直接将列表从小到大进行排序然后返回前K个数即可。所以本题第一种方法就是利用快排然后返回前K个数得到结果，这个方法没什么好说的，只要对快排熟悉即可。&lt;/p&gt;
&lt;!--�0--&gt;
&lt;p&gt;&lt;strong&gt;代码测试：&lt;/strong&gt;&lt;/p&gt;
&lt;!--�1--&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第九天</title>
    <link href="https://crisescode.github.io/blog/2020/07/25/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B9%9D%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/25/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B9%9D%E5%A4%A9/</id>
    <published>2020-07-25T14:05:00.000Z</published>
    <updated>2020-07-27T15:32:14.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ64-滑动窗口的最大值"><a href="#JZ64-滑动窗口的最大值" class="headerlink" title="JZ64 滑动窗口的最大值"></a>JZ64 滑动窗口的最大值</h3><p><strong>题目描述：</strong></p><blockquote><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，<br>{2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p></blockquote><p>这道题其实是昨天最后一道题<a href="http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/" target="_blank" rel="noopener"><code>JZ60</code></a>的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度<code>depth</code>进行解题。在每次需要打印的地方，当深度<code>depth</code>对2取余，为0则从左到右打印，为1则反转打印。</p><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxInWindows(self, num, size):</span><br><span class="line">        # write code here</span><br><span class="line">        if num is None or size &lt;&#x3D; 0:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        max_list &#x3D; []</span><br><span class="line">        for i in range(len(num) - size + 1):</span><br><span class="line">            range_ &#x3D; num[i: i+size]</span><br><span class="line">            max_list.append(max(range_))</span><br><span class="line">        return max_list</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().maxInWindows([2, 3, 4, 2, 6, 2, 5, 1], 2))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [3, 4, 4, 6, 6, 5, 5]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JZ40-数组中只出现一次的数字"><a href="#JZ40-数组中只出现一次的数字" class="headerlink" title="JZ40 数组中只出现一次的数字"></a>JZ40 数组中只出现一次的数字</h3><p><strong>题目描述：</strong></p><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p></blockquote><p><strong>解法思路：</strong></p><!--more--><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 返回[a,b] 其中ab是出现一次的两个数字</span><br><span class="line">    def FindNumsAppearOnce(self, array):</span><br><span class="line">        # write code here</span><br><span class="line">        if array is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        hash_map &#x3D; &#123;&#125;</span><br><span class="line">        for num in array:</span><br><span class="line">            if num in hash_map:</span><br><span class="line">                hash_map[num] +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                hash_map[num] &#x3D; 1</span><br><span class="line"></span><br><span class="line">        res &#x3D; [num for num in hash_map.keys() if hash_map[num] &#x3D;&#x3D; 1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().FindNumsAppearOnce([2, 3, 1, 5, 1, 3, 6, 11, 6, 0, 11, 5]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [2, 0]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ64-滑动窗口的最大值&quot;&gt;&lt;a href=&quot;#JZ64-滑动窗口的最大值&quot; class=&quot;headerlink&quot; title=&quot;JZ64 滑动窗口的最大值&quot;&gt;&lt;/a&gt;JZ64 滑动窗口的最大值&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：&lt;br&gt;{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，&lt;br&gt;{2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题其实是昨天最后一道题&lt;a href=&quot;http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;JZ60&lt;/code&gt;&lt;/a&gt;的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度&lt;code&gt;depth&lt;/code&gt;进行解题。在每次需要打印的地方，当深度&lt;code&gt;depth&lt;/code&gt;对2取余，为0则从左到右打印，为1则反转打印。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;/p&gt;
&lt;!--�64--&gt;
&lt;p&gt;&lt;strong&gt;代码测试：&lt;/strong&gt;&lt;/p&gt;
&lt;!--�65--&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第八天</title>
    <link href="https://crisescode.github.io/blog/2020/07/20/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AB%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/20/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AB%E5%A4%A9/</id>
    <published>2020-07-20T15:43:10.000Z</published>
    <updated>2020-07-27T15:53:18.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ59-按之字形顺序打印二叉树"><a href="#JZ59-按之字形顺序打印二叉树" class="headerlink" title="JZ59 按之字形顺序打印二叉树"></a>JZ59 按之字形顺序打印二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p></blockquote><p><strong>解法思路：</strong><br>这道题其实是昨天最后一道题<a href="http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/" target="_blank" rel="noopener"><code>JZ60</code></a>的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度<code>depth</code>进行解题。在每次需要打印的地方，当深度<code>depth</code>对2取余，为0则从左到右打印，为1则反转打印。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def Print(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot is None:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        depth &#x3D; 0</span><br><span class="line">        node_queue &#x3D; [pRoot]</span><br><span class="line">        res &#x3D; []</span><br><span class="line"></span><br><span class="line">        while node_queue:</span><br><span class="line">            val &#x3D; []</span><br><span class="line">            length &#x3D; len(node_queue)</span><br><span class="line">            for i in range(length):</span><br><span class="line">                current &#x3D; node_queue.pop(0)</span><br><span class="line">                val.append(current.val)</span><br><span class="line"></span><br><span class="line">                if current.left:</span><br><span class="line">                    node_queue.append(current.left)</span><br><span class="line"></span><br><span class="line">                if current.right:</span><br><span class="line">                    node_queue.append(current.right)</span><br><span class="line"></span><br><span class="line">            if depth % 2 &#x3D;&#x3D; 0:</span><br><span class="line">                res.append(val)</span><br><span class="line">            else:</span><br><span class="line">                res.append(list(reversed(val)))</span><br><span class="line"></span><br><span class="line">            depth +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().Print(root))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [[0], [2, 1], [3, 4, 5], [6]]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JZ58-对称的二叉树"><a href="#JZ58-对称的二叉树" class="headerlink" title="JZ58 对称的二叉树"></a>JZ58 对称的二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p></blockquote><p><strong>解法思路：</strong></p><!--more--><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Solution:</span><br><span class="line">    def isSymmetrical(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    num &#x3D; 1</span><br><span class="line">    matrix &#x3D; [[0 for i in range(4)] for j in range(4)]</span><br><span class="line">    for i in range(4):</span><br><span class="line">        for j in range(4):</span><br><span class="line">            matrix[i][j] &#x3D; num</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    print(Solution().printMatrix(matrix))</span><br><span class="line">    print(Solution().printMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]</span><br><span class="line">[1, 2, 4, 6, 8, 10, 9, 7, 5, 3]</span><br></pre></td></tr></table></figure><h3 id="JZ38-二叉树的下一个结点"><a href="#JZ38-二叉树的下一个结点" class="headerlink" title="JZ38 二叉树的下一个结点"></a>JZ38 二叉树的下一个结点</h3><p><strong>题目描述：</strong></p><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def GetNext(self, pNode):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="JZ38-平衡二叉树"><a href="#JZ38-平衡二叉树" class="headerlink" title="JZ38 平衡二叉树"></a>JZ38 平衡二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p></blockquote><blockquote><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def IsBalanced_Solution(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ59-按之字形顺序打印二叉树&quot;&gt;&lt;a href=&quot;#JZ59-按之字形顺序打印二叉树&quot; class=&quot;headerlink&quot; title=&quot;JZ59 按之字形顺序打印二叉树&quot;&gt;&lt;/a&gt;JZ59 按之字形顺序打印二叉树&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;这道题其实是昨天最后一道题&lt;a href=&quot;http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;JZ60&lt;/code&gt;&lt;/a&gt;的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度&lt;code&gt;depth&lt;/code&gt;进行解题。在每次需要打印的地方，当深度&lt;code&gt;depth&lt;/code&gt;对2取余，为0则从左到右打印，为1则反转打印。&lt;/p&gt;
&lt;!--�48--&gt;
&lt;p&gt;&lt;strong&gt;代码测试：&lt;/strong&gt;&lt;/p&gt;
&lt;!--�49--&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第七天</title>
    <link href="https://crisescode.github.io/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/</id>
    <published>2020-07-19T13:33:15.000Z</published>
    <updated>2020-07-20T15:47:40.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ19-顺时针打印矩阵"><a href="#JZ19-顺时针打印矩阵" class="headerlink" title="JZ19 顺时针打印矩阵"></a>JZ19 顺时针打印矩阵</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p></blockquote><p><strong>解法思路：</strong><br>这道题刚开始自己一看，就是想着设置一些索引位置，按照索引位置打印来打印不就行了。后来再认真读题，发现它输入的二维矩阵大小是变化的，不是固定大小，才发现自己的想法太<code>native</code>。</p><p>看了下讨论区，发现只是需要确定几个固定位置的索引值，便可以不管输入矩阵的大小，自适应的便能够确定顺时针打印每个位置的索引，然后再根据这个索引来打印矩阵就行，还真是巧妙。其实在确定好几个顶点的位置，也就相当于确定了方向，然后不管是顺时针还是逆时针，下次都可以方便的解题了。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # matrix类型为二维列表，需要返回列表</span><br><span class="line">    def printMatrix(self, matrix):</span><br><span class="line">        # write code here</span><br><span class="line">        top &#x3D; 0</span><br><span class="line">        bottom &#x3D; len(matrix)</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; len(matrix[0])</span><br><span class="line"></span><br><span class="line">        res &#x3D; []</span><br><span class="line">        # 判断是否越界</span><br><span class="line">        while top &lt; bottom and left &lt; right:</span><br><span class="line">            # 最上面一行，需向右打印</span><br><span class="line">            res.extend([matrix[top][c] for c in range(left, right)])</span><br><span class="line">            # 最右边一行，需向下打印</span><br><span class="line">            res.extend([matrix[r][right - 1] for r in range(top + 1, bottom)])</span><br><span class="line">            # 最下面一行，需向左打印</span><br><span class="line">            if bottom - top &gt; 1:</span><br><span class="line">                res.extend([matrix[bottom - 1][c] for c in range(right - 2, left, -1)]) # 注意需要将右边那个值去除掉</span><br><span class="line">            # 最左边一行，需向上打印</span><br><span class="line">            if right - left &gt; 1:</span><br><span class="line">                res.extend([matrix[r][left] for r in range(bottom - 1, top, -1)])</span><br><span class="line"></span><br><span class="line">            top +&#x3D; 1</span><br><span class="line">            bottom -&#x3D; 1</span><br><span class="line">            left +&#x3D; 1</span><br><span class="line">            right -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    num &#x3D; 1</span><br><span class="line">    matrix &#x3D; [[0 for i in range(4)] for j in range(4)]</span><br><span class="line">    for i in range(4):</span><br><span class="line">        for j in range(4):</span><br><span class="line">            matrix[i][j] &#x3D; num</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    print(Solution().printMatrix(matrix))</span><br><span class="line">    print(Solution().printMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]</span><br><span class="line">[1, 2, 4, 6, 8, 10, 9, 7, 5, 3]</span><br></pre></td></tr></table></figure><h3 id="JZ38-二叉树的深度"><a href="#JZ38-二叉树的深度" class="headerlink" title="JZ38 二叉树的深度"></a>JZ38 二叉树的深度</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        x &#x3D; pRoot</span><br><span class="line"></span><br><span class="line">        left &#x3D; self.TreeDepth(pRoot.left)</span><br><span class="line">        right &#x3D; self.TreeDepth(pRoot.right)</span><br><span class="line"></span><br><span class="line">        return max(left, right) + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution2:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot is None:</span><br><span class="line">            return 0</span><br><span class="line">        q &#x3D; []</span><br><span class="line">        depth &#x3D; 0</span><br><span class="line">        q.append(pRoot)</span><br><span class="line">        while len(q):  # 队列为空时说明没有下一层</span><br><span class="line">            length &#x3D; len(q)</span><br><span class="line">            for i in range(length):  # 遍历层的每个节点看是否有子节点有则加入</span><br><span class="line">                current &#x3D; q.pop(0)  # current为当前遍历到的层中节点，取出，注意pop(-1)为默认，这里要pop(0),取出第一个，先入先出</span><br><span class="line">                if current.left:</span><br><span class="line">                    q.append(current.left)</span><br><span class="line">                if current.right:</span><br><span class="line">                    q.append(current.right)</span><br><span class="line">            depth +&#x3D; 1</span><br><span class="line">        return depth</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="JZ60-把二叉树打印成多行"><a href="#JZ60-把二叉树打印成多行" class="headerlink" title="JZ60 把二叉树打印成多行"></a>JZ60 把二叉树打印成多行</h3><p><strong>题目描述：</strong></p><blockquote><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回二维列表[[1,2],[4,5]]</span><br><span class="line">    def Print(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        node_queue &#x3D; [pRoot]</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while node_queue:</span><br><span class="line">            val &#x3D; []</span><br><span class="line">            length &#x3D; len(node_queue)</span><br><span class="line">            for i in range(length):</span><br><span class="line">                current &#x3D; node_queue.pop(0)</span><br><span class="line">                val.append(current.val)</span><br><span class="line"></span><br><span class="line">                if current.left:</span><br><span class="line">                    node_queue.append(current.left)</span><br><span class="line">                if current.right:</span><br><span class="line">                    node_queue.append(current.right)</span><br><span class="line"></span><br><span class="line">            res.append(val)</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(8)</span><br><span class="line">    root.left &#x3D; TreeNode(6)</span><br><span class="line">    root.right &#x3D; TreeNode(10)</span><br><span class="line">    root.left.left &#x3D; TreeNode(5)</span><br><span class="line">    root.left.right &#x3D; TreeNode(7)</span><br><span class="line">    root.right.left &#x3D; TreeNode(9)</span><br><span class="line">    root.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    print(Solution().Print(root))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [[8], [6, 10], [5, 7, 9, 11]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ19-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#JZ19-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;JZ19 顺时针打印矩阵&quot;&gt;&lt;/a&gt;JZ19 顺时针打印矩阵&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;这道题刚开始自己一看，就是想着设置一些索引位置，按照索引位置打印来打印不就行了。后来再认真读题，发现它输入的二维矩阵大小是变化的，不是固定大小，才发现自己的想法太&lt;code&gt;native&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;看了下讨论区，发现只是需要确定几个固定位置的索引值，便可以不管输入矩阵的大小，自适应的便能够确定顺时针打印每个位置的索引，然后再根据这个索引来打印矩阵就行，还真是巧妙。其实在确定好几个顶点的位置，也就相当于确定了方向，然后不管是顺时针还是逆时针，下次都可以方便的解题了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第六天</title>
    <link href="https://crisescode.github.io/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AD%E5%A4%A9/</id>
    <published>2020-07-13T12:43:55.000Z</published>
    <updated>2020-07-19T14:34:09.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ6-旋转数组的最小数字"><a href="#JZ6-旋转数组的最小数字" class="headerlink" title="JZ6 旋转数组的最小数字"></a>JZ6 旋转数组的最小数字</h3><p><strong>题目描述：</strong></p><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p><strong>解法思路：</strong><br>这题主要是考察二分查找。<strong>二分查找</strong>，又叫折半查找。它的前提是线性表中的数据必须是有序的，线性表必须采用顺序存储。主要思想是：在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找；不断重复上述过程，直至查找成功，或所有查找区域无记录，查找失败为止。</p><p>上面介绍了二分查找的主要思路，而本题难点在于找到中间值与谁进行比较？ 再认真审下题，给定的是非递减排序的数组，也就是“平序”或升序。例如：<code>[1, 2, 3, 3, 3, 5, 6]</code>（“平序”），<code>[1, 2, 3, 4, 5, 6]</code>（升序）。然后再做旋转得到旋转数组<code>[3, 3, 5, 6, 1, 2, 3]</code>，<code>[4, 5, 6, 1, 2, 3]</code>，可以确定的是旋转后的数组<code>nums[0] &gt;= nums[-1]</code>恒成立。</p><p>这样也就得到了<code>nums[mid]</code>与哪个值进行比较了，当然是：</p><ul><li><code>nums[mid] &gt; nums[left]</code> , 这个时候 <code>left = mid + 1</code></li><li><code>nums[mid] &lt; nums[right]</code>, 这个时候 <code>right = mid</code></li><li><code>nums[mid] = nums[right]</code>, 这个时候 <code>left += 1</code></li></ul><p>这里可以一定意义上认为<code>nums[left]</code>与<code>nums[right]</code>近似相等，这样便于理解。</p><blockquote><p>注: 以上<code>nums</code>代表传入的旋转数组，<code>left</code>指数组的第一个数，<code>right</code>指数组末尾的数，<code>mid</code>指数组中间位置的数。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(rotateArray) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; len(rotateArray) - 1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            if rotateArray[left] &lt; rotateArray[right]:</span><br><span class="line">                return rotateArray[left]</span><br><span class="line"></span><br><span class="line">            mid &#x3D; (left + right) &#x2F;&#x2F; 2</span><br><span class="line">            if rotateArray[mid] &gt; rotateArray[left]:</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            elif rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">            else:</span><br><span class="line">                left +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return rotateArray[left]</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().minNumberInRotateArray([1, 0, 1, 1, 1]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure><h3 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h3><p><strong>题目描述：</strong></p><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br> 二叉树的镜像定义如下：</p></blockquote><pre><code> 源二叉树    8   /  \  6   10 / \  / \5  7 9 11镜像二叉树     8   /  \  10   6 / \  / \11 9 7  5</code></pre><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回镜像树的根节点</span><br><span class="line">    def Mirror(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        root.left, root.right &#x3D; \</span><br><span class="line">            self.Mirror(root.right), self.Mirror(root.left)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    tree1 &#x3D; TreeNode(8)</span><br><span class="line">    tree1.left &#x3D; TreeNode(6)</span><br><span class="line">    tree1.right &#x3D; TreeNode(10)</span><br><span class="line">    tree1.left.left &#x3D; TreeNode(5)</span><br><span class="line">    tree1.left.right &#x3D; TreeNode(7)</span><br><span class="line">    tree1.right.left &#x3D; TreeNode(9)</span><br><span class="line">    tree1.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    invert_tree &#x3D; Solution().Mirror(tree1)</span><br><span class="line">    print(Solution().preOrder(invert_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 8 10 11 9 6 7 5 None</span><br></pre></td></tr></table></figure><h3 id="JZ23-二叉搜索树的后序遍历"><a href="#JZ23-二叉搜索树的后序遍历" class="headerlink" title="JZ23 二叉搜索树的后序遍历"></a>JZ23 二叉搜索树的后序遍历</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(sequence) &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        root &#x3D; sequence[-1]</span><br><span class="line">        for index, value in enumerate(sequence):</span><br><span class="line">            if value &gt; root:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for value in sequence[index: -1]:</span><br><span class="line">            if value &lt; root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">        left &#x3D; True</span><br><span class="line">        if index &gt; 0:</span><br><span class="line">            left &#x3D; self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line"></span><br><span class="line">        right &#x3D; True</span><br><span class="line">        if index &lt; len(sequence) - 1:</span><br><span class="line">            right &#x3D; self.VerifySquenceOfBST(sequence[index: -1])</span><br><span class="line"></span><br><span class="line">        return left and right</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    is_binary_tree &#x3D; [1, 3, 5, 9, 12, 10, 7]</span><br><span class="line">    print(Solution().VerifySquenceOfBST(is_binary_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><h3 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h3><p><strong>题目描述：</strong></p><blockquote><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><blockquote><p>输入：8<br>输出：18 </p></blockquote><p><strong>解法思路：</strong></p><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ6-旋转数组的最小数字&quot;&gt;&lt;a href=&quot;#JZ6-旋转数组的最小数字&quot; class=&quot;headerlink&quot; title=&quot;JZ6 旋转数组的最小数字&quot;&gt;&lt;/a&gt;JZ6 旋转数组的最小数字&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。&lt;br&gt;输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。&lt;br&gt;例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。&lt;br&gt;NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;这题主要是考察二分查找。&lt;strong&gt;二分查找&lt;/strong&gt;，又叫折半查找。它的前提是线性表中的数据必须是有序的，线性表必须采用顺序存储。主要思想是：在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找；不断重复上述过程，直至查找成功，或所有查找区域无记录，查找失败为止。&lt;/p&gt;
&lt;p&gt;上面介绍了二分查找的主要思路，而本题难点在于找到中间值与谁进行比较？ 再认真审下题，给定的是非递减排序的数组，也就是“平序”或升序。例如：&lt;code&gt;[1, 2, 3, 3, 3, 5, 6]&lt;/code&gt;（“平序”），&lt;code&gt;[1, 2, 3, 4, 5, 6]&lt;/code&gt;（升序）。然后再做旋转得到旋转数组&lt;code&gt;[3, 3, 5, 6, 1, 2, 3]&lt;/code&gt;，&lt;code&gt;[4, 5, 6, 1, 2, 3]&lt;/code&gt;，可以确定的是旋转后的数组&lt;code&gt;nums[0] &amp;gt;= nums[-1]&lt;/code&gt;恒成立。&lt;/p&gt;
&lt;p&gt;这样也就得到了&lt;code&gt;nums[mid]&lt;/code&gt;与哪个值进行比较了，当然是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums[mid] &amp;gt; nums[left]&lt;/code&gt; , 这个时候 &lt;code&gt;left = mid + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[mid] &amp;lt; nums[right]&lt;/code&gt;, 这个时候 &lt;code&gt;right = mid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[mid] = nums[right]&lt;/code&gt;, 这个时候 &lt;code&gt;left += 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里可以一定意义上认为&lt;code&gt;nums[left]&lt;/code&gt;与&lt;code&gt;nums[right]&lt;/code&gt;近似相等，这样便于理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注: 以上&lt;code&gt;nums&lt;/code&gt;代表传入的旋转数组，&lt;code&gt;left&lt;/code&gt;指数组的第一个数，&lt;code&gt;right&lt;/code&gt;指数组末尾的数，&lt;code&gt;mid&lt;/code&gt;指数组中间位置的数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第五天</title>
    <link href="https://crisescode.github.io/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E5%A4%A9/</id>
    <published>2020-07-13T12:43:35.000Z</published>
    <updated>2020-07-19T15:03:18.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ8-跳台阶"><a href="#JZ8-跳台阶" class="headerlink" title="JZ8 跳台阶"></a>JZ8 跳台阶</h3><p><strong>题目描述：</strong></p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><p><strong>解法思路：</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        res, counter &#x3D; 1, 0</span><br><span class="line">        for i in range(1, number + 1):</span><br><span class="line">            res &#x3D; res + counter</span><br><span class="line">            counter &#x3D; res - counter</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().jumpFloor(3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3</span><br></pre></td></tr></table></figure><h3 id="JZ9-变态跳台阶"><a href="#JZ9-变态跳台阶" class="headerlink" title="JZ9 变态跳台阶"></a>JZ9 变态跳台阶</h3><p><strong>题目描述：</strong></p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        curr, prev &#x3D; 1, 1</span><br><span class="line">        for i in range(1, number):</span><br><span class="line">            curr &#x3D; 2 * prev</span><br><span class="line">            prev &#x3D; curr</span><br><span class="line"></span><br><span class="line">        return curr</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().jumpFloor(3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 4</span><br></pre></td></tr></table></figure><h3 id="JZ10-矩形覆盖"><a href="#JZ10-矩形覆盖" class="headerlink" title="JZ10 矩形覆盖"></a>JZ10 矩形覆盖</h3><p><strong>题目描述：</strong></p><blockquote><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rectCover(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        res, counter &#x3D; 1, 0</span><br><span class="line">        for i in range(1, number + 1):</span><br><span class="line">            res &#x3D; res + counter</span><br><span class="line">            counter &#x3D; res - counter</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().rectCover(4))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 5</span><br></pre></td></tr></table></figure><h3 id="JZ21-栈的压入、弹出序列"><a href="#JZ21-栈的压入、弹出序列" class="headerlink" title="JZ21 栈的压入、弹出序列"></a>JZ21 栈的压入、弹出序列</h3><p><strong>题目描述：</strong></p><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。<br>（注意：这两个序列的长度是相等的）</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def IsPopOrder(self, pushV, popV):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ8-跳台阶&quot;&gt;&lt;a href=&quot;#JZ8-跳台阶&quot; class=&quot;headerlink&quot; title=&quot;JZ8 跳台阶&quot;&gt;&lt;/a&gt;JZ8 跳台阶&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第四天</title>
    <link href="https://crisescode.github.io/blog/2020/07/11/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/11/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%9B%9B%E5%A4%A9/</id>
    <published>2020-07-11T15:10:27.000Z</published>
    <updated>2020-07-11T15:50:48.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ4-重建二叉树"><a href="#JZ4-重建二叉树" class="headerlink" title="JZ4 重建二叉树"></a>JZ4 重建二叉树</h3><p><strong>题目描述：</strong></p><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 [1,2,4,7,3,5,6,8] 和中序遍历序列 [4,7,2,1,5,3,8,6] ，则重建二叉树并返回。</p></blockquote><p><strong>解法思路：</strong><br>使用递归的方法求解。这道题需要对二叉树的性质比较了解，需要熟悉二叉树的几种遍历方式。</p><p><strong>前序遍历是先遍历根节点，然后遍历左节点，最后遍历右节点（根左右）</strong></p><p><strong>中序遍历是先遍历左节点，然后遍历根节点，最后遍历右节点（左根右）</strong></p><p><strong>后序遍历是先遍历左节点，然后遍历右节点，最后遍历根节点（根左右）</strong></p><p>本题给定前序遍历以及中序遍历的序列，可以知道前序遍历第一个值一定是根节点。而根节点在中序遍历中会把左右子树分成两半。因此本题的关键是找到根节点，然后将左右子树依次递归重建得到二叉树。</p><p>使用递归是需要结束条件的，当前序或中序遍历序列为<code>None</code>时，便可推出递归，得到二叉树。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        if not pre or not tin:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        root &#x3D; TreeNode(pre.pop(0))</span><br><span class="line">        index &#x3D; tin.index(root.val)</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; self.reConstructBinaryTree(pre, tin[:index])</span><br><span class="line">        root.right &#x3D; self.reConstructBinaryTree(pre, tin[index + 1:])</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br><span class="line"></span><br><span class="line">    def InOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line">        self.InOrder(root.left)</span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.InOrder(root.right)</span><br><span class="line"></span><br><span class="line">    def BackOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line">        self.BackOrder(root.left)</span><br><span class="line">        self.BackOrder(root.right)</span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br></pre></td></tr></table></figure><p>本题只需写好<code>reConstructBinaryTree</code>这个方法，上面代码其他三个函数是用来前序、中序以及后序遍历重建得到二叉树的，以方便大家调试。<br><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    pre &#x3D; [1, 2, 4, 7, 3, 5, 6, 8]</span><br><span class="line">    tin &#x3D; [4, 7, 2, 1, 5, 3, 8, 6]</span><br><span class="line"></span><br><span class="line">    reTree &#x3D; Solution().reConstructBinaryTree(pre, tin)</span><br><span class="line">    print(&quot;前序遍历：&quot;)</span><br><span class="line">    Solution().preOrder(reTree)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    print(&quot;中序遍历：&quot;)</span><br><span class="line">    Solution().InOrder(reTree)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    print(&quot;后序遍历：&quot;)</span><br><span class="line">    Solution().BackOrder(reTree)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 前序遍历：</span><br><span class="line">1 2 4 7 3 5 6 8 </span><br><span class="line"></span><br><span class="line">中序遍历：</span><br><span class="line">4 7 2 1 5 3 8 6 </span><br><span class="line"></span><br><span class="line">后序遍历：</span><br><span class="line">7 4 2 5 8 6 3 1</span><br></pre></td></tr></table></figure><h3 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h3><p><strong>题目描述：</strong></p><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br> 二叉树的镜像定义如下：</p></blockquote><pre><code> 源二叉树    8   /  \  6   10 / \  / \5  7 9 11镜像二叉树     8   /  \  10   6 / \  / \11 9 7  5</code></pre><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回镜像树的根节点</span><br><span class="line">    def Mirror(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        root.left, root.right &#x3D; \</span><br><span class="line">            self.Mirror(root.right), self.Mirror(root.left)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    tree1 &#x3D; TreeNode(8)</span><br><span class="line">    tree1.left &#x3D; TreeNode(6)</span><br><span class="line">    tree1.right &#x3D; TreeNode(10)</span><br><span class="line">    tree1.left.left &#x3D; TreeNode(5)</span><br><span class="line">    tree1.left.right &#x3D; TreeNode(7)</span><br><span class="line">    tree1.right.left &#x3D; TreeNode(9)</span><br><span class="line">    tree1.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    invert_tree &#x3D; Solution().Mirror(tree1)</span><br><span class="line">    print(Solution().preOrder(invert_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 8 10 11 9 6 7 5 None</span><br></pre></td></tr></table></figure><h3 id="JZ23-二叉搜索树的后序遍历"><a href="#JZ23-二叉搜索树的后序遍历" class="headerlink" title="JZ23 二叉搜索树的后序遍历"></a>JZ23 二叉搜索树的后序遍历</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(sequence) &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        root &#x3D; sequence[-1]</span><br><span class="line">        for index, value in enumerate(sequence):</span><br><span class="line">            if value &gt; root:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for value in sequence[index: -1]:</span><br><span class="line">            if value &lt; root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">        left &#x3D; True</span><br><span class="line">        if index &gt; 0:</span><br><span class="line">            left &#x3D; self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line"></span><br><span class="line">        right &#x3D; True</span><br><span class="line">        if index &lt; len(sequence) - 1:</span><br><span class="line">            right &#x3D; self.VerifySquenceOfBST(sequence[index: -1])</span><br><span class="line"></span><br><span class="line">        return left and right</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    is_binary_tree &#x3D; [1, 3, 5, 9, 12, 10, 7]</span><br><span class="line">    print(Solution().VerifySquenceOfBST(is_binary_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><h3 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h3><p><strong>题目描述：</strong></p><blockquote><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><blockquote><p>输入：8<br>输出：18 </p></blockquote><p><strong>解法思路：</strong></p><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ4-重建二叉树&quot;&gt;&lt;a href=&quot;#JZ4-重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;JZ4 重建二叉树&quot;&gt;&lt;/a&gt;JZ4 重建二叉树&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 [1,2,4,7,3,5,6,8] 和中序遍历序列 [4,7,2,1,5,3,8,6] ，则重建二叉树并返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;使用递归的方法求解。这道题需要对二叉树的性质比较了解，需要熟悉二叉树的几种遍历方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序遍历是先遍历根节点，然后遍历左节点，最后遍历右节点（根左右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序遍历是先遍历左节点，然后遍历根节点，最后遍历右节点（左根右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后序遍历是先遍历左节点，然后遍历右节点，最后遍历根节点（根左右）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本题给定前序遍历以及中序遍历的序列，可以知道前序遍历第一个值一定是根节点。而根节点在中序遍历中会把左右子树分成两半。因此本题的关键是找到根节点，然后将左右子树依次递归重建得到二叉树。&lt;/p&gt;
&lt;p&gt;使用递归是需要结束条件的，当前序或中序遍历序列为&lt;code&gt;None&lt;/code&gt;时，便可推出递归，得到二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第三天</title>
    <link href="https://crisescode.github.io/blog/2020/07/08/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/08/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%89%E5%A4%A9/</id>
    <published>2020-07-08T14:33:32.000Z</published>
    <updated>2020-07-11T15:58:13.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ11-二进制中1的个数"><a href="#JZ11-二进制中1的个数" class="headerlink" title="JZ11 二进制中1的个数"></a>JZ11 二进制中1的个数</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p></blockquote><p><strong>解法思路：</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def NumberOf1(self, n):</span><br><span class="line">    # write code here</span><br><span class="line">    count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    if n &lt; 0:</span><br><span class="line">        n &#x3D; n &amp; 0b11111111111111111111111111111111</span><br><span class="line"></span><br><span class="line">    while n !&#x3D; 0:</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        n &#x3D; n &amp; (n - 1)</span><br><span class="line"></span><br><span class="line">    return count</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().NumberOf1(-11))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 30</span><br></pre></td></tr></table></figure><h3 id="JZ27-字符串的排列"><a href="#JZ27-字符串的排列" class="headerlink" title="JZ27 字符串的排列"></a>JZ27 字符串的排列</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p></blockquote><blockquote><p>输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Permutation(self, ss):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JZ47-求1-2-3-…-n"><a href="#JZ47-求1-2-3-…-n" class="headerlink" title="JZ47 求1 + 2 + 3 + … + n"></a>JZ47 求1 + 2 + 3 + … + n</h3><p><strong>题目描述：</strong></p><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; n</span><br><span class="line">        try:</span><br><span class="line">            res % n</span><br><span class="line">            res +&#x3D; self.Sum_Solution(n - 1)</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution2:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; n</span><br><span class="line">        tmp &#x3D; (res and self.Sum_Solution(n - 1))</span><br><span class="line">        res +&#x3D; tmp</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Sum_Solution(5))</span><br><span class="line">    print(Solution2().Sum_Solution(6))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 15</span><br><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="JZ51-构建乘积数组"><a href="#JZ51-构建乘积数组" class="headerlink" title="JZ51 构建乘积数组"></a>JZ51 构建乘积数组</h3><p><strong>题目描述：</strong></p><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def multiply(self, A):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ11-二进制中1的个数&quot;&gt;&lt;a href=&quot;#JZ11-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;JZ11 二进制中1的个数&quot;&gt;&lt;/a&gt;JZ11 二进制中1的个数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第二天</title>
    <link href="https://crisescode.github.io/blog/2020/07/07/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/07/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E5%A4%A9/</id>
    <published>2020-07-07T14:37:49.000Z</published>
    <updated>2020-07-07T15:07:56.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ49-把字符串转化成整数"><a href="#JZ49-把字符串转化成整数" class="headerlink" title="JZ49 把字符串转化成整数"></a>JZ49 把字符串转化成整数</h3><p><strong>题目描述：</strong></p><blockquote><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入描述：<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述：<br>如果是合法的数值表达则返回该数字，否则返回0</p></blockquote><blockquote><p>示例：<br>输入：<br>+2147483647<br>1a33<br>输出：<br>2147483647<br>0</p></blockquote><p><strong>解法思路：</strong><br>使用了一个很巧妙的方法，用一个字典将字符串”0”-“9”与数字0 - 9做一个映射，然后再用数学上计算一个数字的公式得出这个数。比如：<code>123 = (1 * 10 + 2 ) * 10 + 3</code>。需要注意字符串开头的正负号，从而判断得到的数字是整数还是负数。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def StrToInt(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(s) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        str2num &#x3D; &#123;</span><br><span class="line">            &quot;0&quot;: 0, &quot;1&quot;: 1, &quot;2&quot;: 2, &quot;3&quot;: 3, &quot;4&quot;: 4,</span><br><span class="line">            &quot;5&quot;: 5, &quot;6&quot;: 6, &quot;7&quot;: 7, &quot;8&quot;: 8, &quot;9&quot;: 9,</span><br><span class="line">            &quot;+&quot;: 1, &quot;-&quot;: -1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum &#x3D; 0</span><br><span class="line">        sign &#x3D; 1</span><br><span class="line">        for c in s:</span><br><span class="line">            if c in str2num:</span><br><span class="line">                if c &#x3D;&#x3D; &quot;+&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;+&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                if c &#x3D;&#x3D; &quot;-&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;-&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                sum &#x3D; sum * 10 + str2num[c]</span><br><span class="line">            else:</span><br><span class="line">                sum &#x3D; 0</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return sum * sign</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    s &#x3D; &quot;-98210&quot;</span><br><span class="line">    print(Solution().StrToInt(s))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 98210</span><br></pre></td></tr></table></figure><h3 id="JZ7-斐波那契数列"><a href="#JZ7-斐波那契数列" class="headerlink" title="JZ7 斐波那契数列"></a>JZ7 斐波那契数列</h3><p><strong>题目描述：</strong></p><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）(n&lt;=39)。</p></blockquote><p><strong>解法一思路：</strong><br>直接根据数学公式<code>f(n) = f(n - 1) + f(n - 2)</code>，截至条件是当<code>n = 1, f(n) = 1</code>，<code>n = 0, f(0) = 0</code>。利用<strong>递归法</strong>进行求解，这种方法时间复杂度很大，为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line">        else:</span><br><span class="line">            return self.Fibonacci(n-1) + self.Fibonacci(n-2)</span><br></pre></td></tr></table></figure><p><strong>解法二思路：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        n1, n2, n3 &#x3D; 0, 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            n3 &#x3D; n1 + n2</span><br><span class="line">            n1 &#x3D; n2</span><br><span class="line">            n2 &#x3D; n3</span><br><span class="line"></span><br><span class="line">        return n3</span><br></pre></td></tr></table></figure><p><strong>解法三思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution3:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        sum, one &#x3D; 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            sum &#x3D; sum + one</span><br><span class="line">            one &#x3D; sum - one</span><br><span class="line"></span><br><span class="line">        return sum</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Fibonacci(8))</span><br><span class="line">    print(Solution2().Fibonacci(8))</span><br><span class="line">    print(Solution3().Fibonacci(8))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br></pre></td></tr></table></figure><h3 id="JZ48-不用加减乘除做加法"><a href="#JZ48-不用加减乘除做加法" class="headerlink" title="JZ48 不用加减乘除做加法"></a>JZ48 不用加减乘除做加法</h3><p><strong>题目描述：</strong></p><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Add(self, num1, num2):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ49-把字符串转化成整数&quot;&gt;&lt;a href=&quot;#JZ49-把字符串转化成整数&quot; class=&quot;headerlink&quot; title=&quot;JZ49 把字符串转化成整数&quot;&gt;&lt;/a&gt;JZ49 把字符串转化成整数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0&lt;br&gt;输入描述：&lt;br&gt;输入一个字符串,包括数字字母符号,可以为空&lt;br&gt;输出描述：&lt;br&gt;如果是合法的数值表达则返回该数字，否则返回0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;示例：&lt;br&gt;输入：&lt;br&gt;+2147483647&lt;br&gt;1a33&lt;br&gt;输出：&lt;br&gt;2147483647&lt;br&gt;0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法思路：&lt;/strong&gt;&lt;br&gt;使用了一个很巧妙的方法，用一个字典将字符串”0”-“9”与数字0 - 9做一个映射，然后再用数学上计算一个数字的公式得出这个数。比如：&lt;code&gt;123 = (1 * 10 + 2 ) * 10 + 3&lt;/code&gt;。需要注意字符串开头的正负号，从而判断得到的数字是整数还是负数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 第一天</title>
    <link href="https://crisescode.github.io/blog/2020/07/06/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://crisescode.github.io/blog/2020/07/06/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%80%E5%A4%A9/</id>
    <published>2020-07-06T14:10:47.000Z</published>
    <updated>2020-07-09T13:31:42.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JZ16-合并两个排序的链表"><a href="#JZ16-合并两个排序的链表" class="headerlink" title="JZ16 合并两个排序的链表"></a>JZ16 合并两个排序的链表</h3><p><strong>题目描述：</strong></p><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><p><strong>解法一思路：</strong><br>使用迭代的方法。先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。</p><p>然后初始化一个新链表，依次比较两个有序链表的值，哪个链表的值较小，则新链表的指针指向该值。继续循环，依次比较，最终返回单调递增的新链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Solution2:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead1 is None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 is None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        node &#x3D; sorted_node &#x3D; ListNode(0)</span><br><span class="line"></span><br><span class="line">        while pHead1 and pHead2:</span><br><span class="line">            if pHead1.val &lt; pHead2.val:</span><br><span class="line">                node.next &#x3D; pHead1</span><br><span class="line">                pHead1 &#x3D; pHead1.next</span><br><span class="line">            else:</span><br><span class="line">                node.next &#x3D; pHead2</span><br><span class="line">                pHead2 &#x3D; pHead2.next</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">        if pHead1 or pHead2:</span><br><span class="line">            node.next &#x3D; pHead1 or pHead2</span><br><span class="line"></span><br><span class="line">        return sorted_node.next</span><br><span class="line"></span><br><span class="line">    def travel_list(self, node):</span><br><span class="line">        while node is not None:</span><br><span class="line">            print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            node &#x3D; node.next</span><br></pre></td></tr></table></figure><p><strong>解法二思路：</strong><br>使用递归的方法。大体思路同上，先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。</p><p>然后依次比较两个有序链表的值，哪个链表的值较小，则将该节点赋值给新链表。使用递归，直至其中一个链表为None，最终返回和并得到的单调递增链表。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead1 is None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 is None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        if pHead1.val &lt; pHead2.val:</span><br><span class="line">            sorted_list &#x3D; pHead1</span><br><span class="line">            sorted_list.next &#x3D; self.Merge(pHead1.next, pHead2)</span><br><span class="line">        else:</span><br><span class="line">            sorted_list &#x3D; pHead2</span><br><span class="line">            sorted_list.next &#x3D; self.Merge(pHead1, pHead2.next)</span><br><span class="line"></span><br><span class="line">        return sorted_list</span><br><span class="line"></span><br><span class="line">    def travel_list(self, node):</span><br><span class="line">        while node is not None:</span><br><span class="line">            print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            node &#x3D; node.next</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    node_1 &#x3D; ListNode(0)</span><br><span class="line">    node_1.next &#x3D; ListNode(4)</span><br><span class="line">    node_1.next.next &#x3D; ListNode(10)</span><br><span class="line">    node_2 &#x3D; ListNode(2)</span><br><span class="line">    node_2.next &#x3D; ListNode(3)</span><br><span class="line">    node_2.next.next &#x3D; ListNode(12)</span><br><span class="line">    solu_1 &#x3D; Solution()</span><br><span class="line">    # print(solu_1.travel_list(solu_1.Merge(node_1, node_2)))</span><br><span class="line">    solu_2 &#x3D; Solution2()</span><br><span class="line">    print(solu_2.travel_list(solu_2.Merge(node_1, node_2)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 2 3 4 10 12 None</span><br></pre></td></tr></table></figure><h3 id="JZ14-链表中倒数第k个结点"><a href="#JZ14-链表中倒数第k个结点" class="headerlink" title="JZ14 链表中倒数第k个结点"></a>JZ14 链表中倒数第k个结点</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><p><strong>解法一思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lass ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 时间复杂度： O(n)</span><br><span class="line">    # 空间复杂度： O(n)</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; []</span><br><span class="line"></span><br><span class="line">        while head is not None:</span><br><span class="line">            res.insert(0, head.val)</span><br><span class="line">            head &#x3D; head.next</span><br><span class="line"></span><br><span class="line">        if len(res) &lt; k or k &lt; 1:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        return res[k-1]</span><br><span class="line"></span><br><span class="line">    def travel_listNode(self, listNode):</span><br><span class="line">        while listNode:</span><br><span class="line">            print(listNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br></pre></td></tr></table></figure><p><strong>解法二思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    # 时间复杂度： O(n)</span><br><span class="line">    # 空间复杂度： O(1)</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        if k &lt; 0 or head is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        slow, fast &#x3D; head, head</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        while fast.next is not None:</span><br><span class="line">            fast &#x3D; fast.next</span><br><span class="line">            if count &gt;&#x3D; k - 1:</span><br><span class="line">                slow &#x3D; slow.next</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        if count &gt;&#x3D; k - 1:</span><br><span class="line">            return slow.val</span><br><span class="line"></span><br><span class="line">        return None</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(4) </span><br><span class="line"></span><br><span class="line">    print(Solution().travel_listNode(curr))</span><br><span class="line">    print(Solution().FindKthToTail(curr, 5))</span><br><span class="line">    print(Solution2().FindKthToTail(curr, 5))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 1 2 3 4 None</span><br><span class="line">&gt;&gt;&gt; 0</span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure><h3 id="JZ15-反转链表"><a href="#JZ15-反转链表" class="headerlink" title="JZ15 反转链表"></a>JZ15 反转链表</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回ListNode</span><br><span class="line">    def ReverseList(self, pHead):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pHead or pHead.next is None:</span><br><span class="line">            return pHead</span><br><span class="line"></span><br><span class="line">        curr, prev &#x3D; pHead, None</span><br><span class="line">        while curr:</span><br><span class="line">            tmp &#x3D; curr.next</span><br><span class="line">            curr.next &#x3D; prev</span><br><span class="line">            prev &#x3D; curr</span><br><span class="line">            curr &#x3D; tmp</span><br><span class="line"></span><br><span class="line">        return prev</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    # print(head)</span><br><span class="line">    print(curr)</span><br><span class="line"></span><br><span class="line">    res &#x3D; Solution().ReverseList(curr)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><h3 id="JZ13-从尾到头打印链表"><a href="#JZ13-从尾到头打印链表" class="headerlink" title="JZ13 从尾到头打印链表"></a>JZ13 从尾到头打印链表</h3><p><strong>题目描述：</strong></p><blockquote><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p></blockquote><p><strong>解法思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</span><br><span class="line">    def printListFromTailToHead(self, listNode):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while listNode:</span><br><span class="line">            res.insert(0, listNode.val)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def travel_listNode(self, listNode):</span><br><span class="line">        while listNode:</span><br><span class="line">            print(listNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br></pre></td></tr></table></figure><p><strong>代码测试：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(4)</span><br><span class="line"></span><br><span class="line">    print(Solution().travel_listNode(curr))</span><br><span class="line">    print(Solution().printListFromTailToHead(curr))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JZ16-合并两个排序的链表&quot;&gt;&lt;a href=&quot;#JZ16-合并两个排序的链表&quot; class=&quot;headerlink&quot; title=&quot;JZ16 合并两个排序的链表&quot;&gt;&lt;/a&gt;JZ16 合并两个排序的链表&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法一思路：&lt;/strong&gt;&lt;br&gt;使用迭代的方法。先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。&lt;/p&gt;
&lt;p&gt;然后初始化一个新链表，依次比较两个有序链表的值，哪个链表的值较小，则新链表的指针指向该值。继续循环，依次比较，最终返回单调递增的新链表。&lt;/p&gt;
&lt;!--�770--&gt;
&lt;p&gt;&lt;strong&gt;解法二思路：&lt;/strong&gt;&lt;br&gt;使用递归的方法。大体思路同上，先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。&lt;/p&gt;
&lt;p&gt;然后依次比较两个有序链表的值，哪个链表的值较小，则将该节点赋值给新链表。使用递归，直至其中一个链表为None，最终返回和并得到的单调递增链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://Crisescode.github.io/blog/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="https://Crisescode.github.io/blog/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>NLP（1）文本分类知识梳理</title>
    <link href="https://crisescode.github.io/blog/2020/06/27/NLP%EF%BC%881%EF%BC%89%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>https://crisescode.github.io/blog/2020/06/27/NLP%EF%BC%881%EF%BC%89%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</id>
    <published>2020-06-27T07:17:47.000Z</published>
    <updated>2020-08-08T06:58:03.790Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="NLP" scheme="https://Crisescode.github.io/blog/categories/NLP/"/>
    
      <category term="文本分类" scheme="https://Crisescode.github.io/blog/categories/NLP/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="文本分类" scheme="https://Crisescode.github.io/blog/tags/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://crisescode.github.io/blog/2020/06/21/hello-world/"/>
    <id>https://crisescode.github.io/blog/2020/06/21/hello-world/</id>
    <published>2020-06-21T14:21:53.997Z</published>
    <updated>2020-06-18T05:46:18.345Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python之函数式编程模块（2）</title>
    <link href="https://crisescode.github.io/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/"/>
    <id>https://crisescode.github.io/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/</id>
    <published>2020-06-19T06:35:04.000Z</published>
    <updated>2020-07-31T13:32:06.978Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是讲解一些函数式编程常用的模块，比如：<code>itertools</code>, <code>functools</code>以及<code>operator</code>。</p><h2 id="一、itertools-–用以创建迭代器的模块"><a href="#一、itertools-–用以创建迭代器的模块" class="headerlink" title="一、itertools –用以创建迭代器的模块"></a>一、itertools –用以创建迭代器的模块</h2><a id="more"></a><h2 id="二、functools-–-高阶函数可调用对象上的操作"><a href="#二、functools-–-高阶函数可调用对象上的操作" class="headerlink" title="二、functools – 高阶函数可调用对象上的操作"></a>二、functools – 高阶函数可调用对象上的操作</h2><h2 id="三、operator-–-标准运算符替代函数"><a href="#三、operator-–-标准运算符替代函数" class="headerlink" title="三、operator – 标准运算符替代函数"></a>三、operator – 标准运算符替代函数</h2><p>在函数式编程中，我们经常需要把算术运算符当作函数使用，因此可以借助operator模块。operator 模块提供了一套与Python的内置运算符对应的高效率函数。例如，operator.add(x, y) 与表达式 x+y 相同。</p><p>operator 模块为多个算术运算符提供了对应的函数，从而避免编写<br><code>lambda a, b: a * b</code> 这种平凡的匿名函数。这两种做法具体如下：</p><ul><li>使用<code>lambda a, b: a * b</code>匿名函数来计算阶乘：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def fact(n):</span><br><span class="line">...     return reduce(mul, range(1, n+1))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure><ul><li>使用<code>operator.mul</code>函数来计算阶乘：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def fact(n):</span><br><span class="line">...     return reduce(mul, range(1, n+1))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure><p>operator 模块中还有一类函数，能替代从系列中取出元素或读取对象属性的lambda表达式：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是讲解一些函数式编程常用的模块，比如：&lt;code&gt;itertools&lt;/code&gt;, &lt;code&gt;functools&lt;/code&gt;以及&lt;code&gt;operator&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一、itertools-–用以创建迭代器的模块&quot;&gt;&lt;a href=&quot;#一、itertools-–用以创建迭代器的模块&quot; class=&quot;headerlink&quot; title=&quot;一、itertools –用以创建迭代器的模块&quot;&gt;&lt;/a&gt;一、itertools –用以创建迭代器的模块&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://Crisescode.github.io/blog/categories/Python/"/>
    
    
      <category term="函数式编程" scheme="https://Crisescode.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="高级语法" scheme="https://Crisescode.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python之函数式编程模块（1）</title>
    <link href="https://crisescode.github.io/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/"/>
    <id>https://crisescode.github.io/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/</id>
    <published>2020-06-19T04:52:51.000Z</published>
    <updated>2020-07-31T13:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编程方式介绍"><a href="#一、编程方式介绍" class="headerlink" title="一、编程方式介绍"></a>一、编程方式介绍</h2><p>一般编程语言支持通过以下几种方式来解决具体的问题：</p><ul><li>大多数的编程语言都是<strong>过程式</strong>的，也就是我们常说的面向过程的编程方式。而所谓程序是指令的列表，告诉计算机如何处理程序的输入。C、Pascal甚至Unix shell都是过程式语言。</li><li>然后有一些编程语言是<strong>声明式</strong>的，主要是你需要编写一个用来描述待解决问题的说明，然后这个语言的具体实现会指明怎样高效的进行计算并解决问题。SQL 可能是你最熟悉的声明式语言了。 一个 SQL 查询语句描述了你想要检索的数据集，并且 SQL 引擎会决定是扫描整张表还是使用索引，应该先执行哪些子句等等。</li><li><strong>面向对象</strong>编程语言会操作一组对象。其中对象拥有内部状态，并能够以某种方式支持请求和修改这个内部状态的方法。Smalltalk 和 Java 都是面向对象的语言。C++ 和 Python 支持面向对象编程，但并不强制使用面向对象特性。</li><li>而<strong>函数式</strong>编程则是将一个问题分解成一系列函数。理想情况下，函数只接受输入并产生输出，没有任何内部状态会影响为给定输入产生的输出。众所周知的函数式语言包括ML家族(标准ML、OCaml和其他变体)和Haskell。</li></ul><a id="more"></a><p>一般语言设计者在设计语言时，会选择侧重强调一种特定的编程方式，但这会让以不同方式来编写程序变得困难。因此有些语言就被设计成多范式语言，用以支持以上几种不同的编程方式。其中<strong>Lisp，C++ 和 Python 都是多范式语言；使用这些语言，你可以编写主要为过程式，面向对象或者函数式的程序和函数库。</strong>在大型程序中，不同的部分可能会采用不同的方式编写；比如 GUI 可能是面向对象的而处理逻辑则是过程式或者函数式。</p><p>这篇文章主要是来讲解函数式编程，因此接下来主要围绕函数式编程进行展开。</p><h2 id="二、函数式编程"><a href="#二、函数式编程" class="headerlink" title="二、函数式编程"></a>二、函数式编程</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>函数式编程：即为给定输入，输入会流经一系列函数，每个函数接收输入并输出结果。并且这个过程，在每个函数内部并不会修改全局变量或者有其他副作用。函数式编程允许把函数本身作为参数传入另一个函数，还允许返回一个函数。</p><h3 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a>2.2 特点</h3><p>函数式风格有其理论和实践上的优点：</p><ul><li>形式证明</li><li>模块化</li><li>组合性</li><li>易于调试和测试</li></ul><h2 id="三、函数式编程实践"><a href="#三、函数式编程实践" class="headerlink" title="三、函数式编程实践"></a>三、函数式编程实践</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、编程方式介绍&quot;&gt;&lt;a href=&quot;#一、编程方式介绍&quot; class=&quot;headerlink&quot; title=&quot;一、编程方式介绍&quot;&gt;&lt;/a&gt;一、编程方式介绍&lt;/h2&gt;&lt;p&gt;一般编程语言支持通过以下几种方式来解决具体的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大多数的编程语言都是&lt;strong&gt;过程式&lt;/strong&gt;的，也就是我们常说的面向过程的编程方式。而所谓程序是指令的列表，告诉计算机如何处理程序的输入。C、Pascal甚至Unix shell都是过程式语言。&lt;/li&gt;
&lt;li&gt;然后有一些编程语言是&lt;strong&gt;声明式&lt;/strong&gt;的，主要是你需要编写一个用来描述待解决问题的说明，然后这个语言的具体实现会指明怎样高效的进行计算并解决问题。SQL 可能是你最熟悉的声明式语言了。 一个 SQL 查询语句描述了你想要检索的数据集，并且 SQL 引擎会决定是扫描整张表还是使用索引，应该先执行哪些子句等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向对象&lt;/strong&gt;编程语言会操作一组对象。其中对象拥有内部状态，并能够以某种方式支持请求和修改这个内部状态的方法。Smalltalk 和 Java 都是面向对象的语言。C++ 和 Python 支持面向对象编程，但并不强制使用面向对象特性。&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;函数式&lt;/strong&gt;编程则是将一个问题分解成一系列函数。理想情况下，函数只接受输入并产生输出，没有任何内部状态会影响为给定输入产生的输出。众所周知的函数式语言包括ML家族(标准ML、OCaml和其他变体)和Haskell。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://Crisescode.github.io/blog/categories/Python/"/>
    
    
      <category term="函数式编程" scheme="https://Crisescode.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="高级语法" scheme="https://Crisescode.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>My first post</title>
    <link href="https://crisescode.github.io/blog/2020/06/18/My-first-post/"/>
    <id>https://crisescode.github.io/blog/2020/06/18/My-first-post/</id>
    <published>2020-06-18T06:01:38.000Z</published>
    <updated>2020-06-18T06:01:38.066Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
