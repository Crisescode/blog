<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My first post</title>
    <url>/blog/2020/06/18/My-first-post/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2020/06/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python之函数式编程模块（2）</title>
    <url>/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>这篇文章主要是讲解一些函数式编程常用的模块，比如：<code>itertools</code>, <code>functools</code>以及<code>operator</code>。</p>
<h2 id="一、itertools-–用以创建迭代器的模块"><a href="#一、itertools-–用以创建迭代器的模块" class="headerlink" title="一、itertools –用以创建迭代器的模块"></a>一、itertools –用以创建迭代器的模块</h2><a id="more"></a>

<h2 id="二、functools-–-高阶函数可调用对象上的操作"><a href="#二、functools-–-高阶函数可调用对象上的操作" class="headerlink" title="二、functools – 高阶函数可调用对象上的操作"></a>二、functools – 高阶函数可调用对象上的操作</h2><h2 id="三、operator-–-标准运算符替代函数"><a href="#三、operator-–-标准运算符替代函数" class="headerlink" title="三、operator – 标准运算符替代函数"></a>三、operator – 标准运算符替代函数</h2><p>在函数式编程中，我们经常需要把算术运算符当作函数使用，因此可以借助operator模块。operator 模块提供了一套与Python的内置运算符对应的高效率函数。例如，operator.add(x, y) 与表达式 x+y 相同。</p>
<p>operator 模块为多个算术运算符提供了对应的函数，从而避免编写<br><code>lambda a, b: a * b</code> 这种平凡的匿名函数。这两种做法具体如下：</p>
<ul>
<li>使用<code>lambda a, b: a * b</code>匿名函数来计算阶乘：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def fact(n):</span><br><span class="line">...     return reduce(mul, range(1, n+1))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>operator.mul</code>函数来计算阶乘：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def fact(n):</span><br><span class="line">...     return reduce(mul, range(1, n+1))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure>

<p>operator 模块中还有一类函数，能替代从系列中取出元素或读取对象属性的lambda表达式：</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之函数式编程模块（1）</title>
    <url>/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="一、编程方式介绍"><a href="#一、编程方式介绍" class="headerlink" title="一、编程方式介绍"></a>一、编程方式介绍</h2><p>一般编程语言支持通过以下几种方式来解决具体的问题：</p>
<ul>
<li>大多数的编程语言都是<strong>过程式</strong>的，也就是我们常说的面向过程的编程方式。而所谓程序是指令的列表，告诉计算机如何处理程序的输入。C、Pascal甚至Unix shell都是过程式语言。</li>
<li>然后有一些编程语言是<strong>声明式</strong>的，主要是你需要编写一个用来描述待解决问题的说明，然后这个语言的具体实现会指明怎样高效的进行计算并解决问题。SQL 可能是你最熟悉的声明式语言了。 一个 SQL 查询语句描述了你想要检索的数据集，并且 SQL 引擎会决定是扫描整张表还是使用索引，应该先执行哪些子句等等。</li>
<li><strong>面向对象</strong>编程语言会操作一组对象。其中对象拥有内部状态，并能够以某种方式支持请求和修改这个内部状态的方法。Smalltalk 和 Java 都是面向对象的语言。C++ 和 Python 支持面向对象编程，但并不强制使用面向对象特性。</li>
<li>而<strong>函数式</strong>编程则是将一个问题分解成一系列函数。理想情况下，函数只接受输入并产生输出，没有任何内部状态会影响为给定输入产生的输出。众所周知的函数式语言包括ML家族(标准ML、OCaml和其他变体)和Haskell。</li>
</ul>
<a id="more"></a>

<p>一般语言设计者在设计语言时，会选择侧重强调一种特定的编程方式，但这会让以不同方式来编写程序变得困难。因此有些语言就被设计成多范式语言，用以支持以上几种不同的编程方式。其中<strong>Lisp，C++ 和 Python 都是多范式语言；使用这些语言，你可以编写主要为过程式，面向对象或者函数式的程序和函数库。</strong>在大型程序中，不同的部分可能会采用不同的方式编写；比如 GUI 可能是面向对象的而处理逻辑则是过程式或者函数式。</p>
<p>这篇文章主要是来讲解函数式编程，因此接下来主要围绕函数式编程进行展开。</p>
<h2 id="二、函数式编程"><a href="#二、函数式编程" class="headerlink" title="二、函数式编程"></a>二、函数式编程</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>函数式编程：即为给定输入，输入会流经一系列函数，每个函数接收输入并输出结果。并且这个过程，在每个函数内部并不会修改全局变量或者有其他副作用。函数式编程允许把函数本身作为参数传入另一个函数，还允许返回一个函数。</p>
<h3 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a>2.2 特点</h3><p>函数式风格有其理论和实践上的优点：</p>
<ul>
<li>形式证明</li>
<li>模块化</li>
<li>组合性</li>
<li>易于调试和测试</li>
</ul>
<h2 id="三、函数式编程实践"><a href="#三、函数式编程实践" class="headerlink" title="三、函数式编程实践"></a>三、函数式编程实践</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP（1）文本分类知识梳理</title>
    <url>/blog/2020/06/27/NLP%EF%BC%881%EF%BC%89%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>剑指offer 第一天</title>
    <url>/blog/2020/07/06/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ16-合并两个排序的链表"><a href="#JZ16-合并两个排序的链表" class="headerlink" title="JZ16 合并两个排序的链表"></a>JZ16 合并两个排序的链表</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<p><strong>解法一思路：</strong><br>使用迭代的方法，比较pHead1以及pHead2的值，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Solution2:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead1 is None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 is None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        node &#x3D; sorted_node &#x3D; ListNode(0)</span><br><span class="line"></span><br><span class="line">        while pHead1 and pHead2:</span><br><span class="line">            if pHead1.val &lt; pHead2.val:</span><br><span class="line">                node.next &#x3D; pHead1</span><br><span class="line">                pHead1 &#x3D; pHead1.next</span><br><span class="line">            else:</span><br><span class="line">                node.next &#x3D; pHead2</span><br><span class="line">                pHead2 &#x3D; pHead2.next</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">        if pHead1 or pHead2:</span><br><span class="line">            node.next &#x3D; pHead1 or pHead2</span><br><span class="line"></span><br><span class="line">        return sorted_node.next</span><br><span class="line"></span><br><span class="line">    def travel_list(self, node):</span><br><span class="line">        while node is not None:</span><br><span class="line">            print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            node &#x3D; node.next</span><br></pre></td></tr></table></figure>
<p><strong>解法二思路：</strong><br>使用递归的思想</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead1 is None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 is None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        if pHead1.val &lt; pHead2.val:</span><br><span class="line">            sorted_list &#x3D; pHead1</span><br><span class="line">            sorted_list.next &#x3D; self.Merge(pHead1.next, pHead2)</span><br><span class="line">        else:</span><br><span class="line">            sorted_list &#x3D; pHead2</span><br><span class="line">            sorted_list.next &#x3D; self.Merge(pHead2.next, pHead1)</span><br><span class="line"></span><br><span class="line">        return sorted_list</span><br><span class="line"></span><br><span class="line">    def travel_list(self, node):</span><br><span class="line">        while node is not None:</span><br><span class="line">            print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            node &#x3D; node.next</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    node_1 &#x3D; ListNode(0)</span><br><span class="line">    node_1.next &#x3D; ListNode(4)</span><br><span class="line">    node_1.next.next &#x3D; ListNode(10)</span><br><span class="line">    node_2 &#x3D; ListNode(2)</span><br><span class="line">    node_2.next &#x3D; ListNode(3)</span><br><span class="line">    node_2.next.next &#x3D; ListNode(12)</span><br><span class="line">    solu_1 &#x3D; Solution()</span><br><span class="line">    # print(solu_1.travel_list(solu_1.Merge(node_1, node_2)))</span><br><span class="line">    solu_2 &#x3D; Solution2()</span><br><span class="line">    print(solu_2.travel_list(solu_2.Merge(node_1, node_2)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 2 3 4 10 12 None</span><br></pre></td></tr></table></figure>

<h3 id="JZ14-链表中倒数第k个结点"><a href="#JZ14-链表中倒数第k个结点" class="headerlink" title="JZ14 链表中倒数第k个结点"></a>JZ14 链表中倒数第k个结点</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p><strong>解法一思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lass ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 时间复杂度： O(n)</span><br><span class="line">    # 空间复杂度： O(n)</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; []</span><br><span class="line"></span><br><span class="line">        while head is not None:</span><br><span class="line">            res.insert(0, head.val)</span><br><span class="line">            head &#x3D; head.next</span><br><span class="line"></span><br><span class="line">        if len(res) &lt; k or k &lt; 1:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        return res[k-1]</span><br><span class="line"></span><br><span class="line">    def travel_listNode(self, listNode):</span><br><span class="line">        while listNode:</span><br><span class="line">            print(listNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br></pre></td></tr></table></figure>

<p><strong>解法二思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    # 时间复杂度： O(n)</span><br><span class="line">    # 空间复杂度： O(1)</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        if k &lt; 0 or head is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        slow, fast &#x3D; head, head</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        while fast.next is not None:</span><br><span class="line">            fast &#x3D; fast.next</span><br><span class="line">            if count &gt;&#x3D; k - 1:</span><br><span class="line">                slow &#x3D; slow.next</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        if count &gt;&#x3D; k - 1:</span><br><span class="line">            return slow.val</span><br><span class="line"></span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(4) </span><br><span class="line"></span><br><span class="line">    print(Solution().travel_listNode(curr))</span><br><span class="line">    print(Solution().FindKthToTail(curr, 5))</span><br><span class="line">    print(Solution2().FindKthToTail(curr, 5))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 1 2 3 4 None</span><br><span class="line">&gt;&gt;&gt; 0</span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure>
<h3 id="JZ15-反转链表"><a href="#JZ15-反转链表" class="headerlink" title="JZ15 反转链表"></a>JZ15 反转链表</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回ListNode</span><br><span class="line">    def ReverseList(self, pHead):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pHead or pHead.next is None:</span><br><span class="line">            return pHead</span><br><span class="line"></span><br><span class="line">        curr, prev &#x3D; pHead, None</span><br><span class="line">        while curr:</span><br><span class="line">            tmp &#x3D; curr.next</span><br><span class="line">            curr.next &#x3D; prev</span><br><span class="line">            prev &#x3D; curr</span><br><span class="line">            curr &#x3D; tmp</span><br><span class="line"></span><br><span class="line">        return prev</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    # print(head)</span><br><span class="line">    print(curr)</span><br><span class="line"></span><br><span class="line">    res &#x3D; Solution().ReverseList(curr)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>

<h3 id="JZ13-从尾到头打印链表"><a href="#JZ13-从尾到头打印链表" class="headerlink" title="JZ13 从尾到头打印链表"></a>JZ13 从尾到头打印链表</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</span><br><span class="line">    def printListFromTailToHead(self, listNode):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while listNode:</span><br><span class="line">            res.insert(0, listNode.val)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def travel_listNode(self, listNode):</span><br><span class="line">        while listNode:</span><br><span class="line">            print(listNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(4)</span><br><span class="line"></span><br><span class="line">    print(Solution().travel_listNode(curr))</span><br><span class="line">    print(Solution().printListFromTailToHead(curr))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第二天</title>
    <url>/blog/2020/07/07/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ49-把字符串转化成整数"><a href="#JZ49-把字符串转化成整数" class="headerlink" title="JZ49 把字符串转化成整数"></a>JZ49 把字符串转化成整数</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入描述：<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述：<br>如果是合法的数值表达则返回该数字，否则返回0</p>
</blockquote>
<blockquote>
<p>示例：<br>输入：<br>+2147483647<br>1a33<br>输出：<br>2147483647<br>0</p>
</blockquote>
<p><strong>解法思路：</strong><br>使用了一个很巧妙的方法，用一个字典将字符串”0”-“9”与数字0 - 9做一个映射，然后再用数学上计算一个数字的公式得出这个数。比如：<code>123 = (1 * 10 + 2 ) * 10 + 3</code>。需要注意字符串开头的正负号，从而判断得到的数字是整数还是负数。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def StrToInt(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(s) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        str2num &#x3D; &#123;</span><br><span class="line">            &quot;0&quot;: 0, &quot;1&quot;: 1, &quot;2&quot;: 2, &quot;3&quot;: 3, &quot;4&quot;: 4,</span><br><span class="line">            &quot;5&quot;: 5, &quot;6&quot;: 6, &quot;7&quot;: 7, &quot;8&quot;: 8, &quot;9&quot;: 9,</span><br><span class="line">            &quot;+&quot;: 1, &quot;-&quot;: -1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum &#x3D; 0</span><br><span class="line">        sign &#x3D; 1</span><br><span class="line">        for c in s:</span><br><span class="line">            if c in str2num:</span><br><span class="line">                if c &#x3D;&#x3D; &quot;+&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;+&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                if c &#x3D;&#x3D; &quot;-&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;-&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                sum &#x3D; sum * 10 + str2num[c]</span><br><span class="line">            else:</span><br><span class="line">                sum &#x3D; 0</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return sum * sign</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    s &#x3D; &quot;-98210&quot;</span><br><span class="line">    print(Solution().StrToInt(s))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 98210</span><br></pre></td></tr></table></figure>

<h3 id="JZ7-斐波那契数列"><a href="#JZ7-斐波那契数列" class="headerlink" title="JZ7 斐波那契数列"></a>JZ7 斐波那契数列</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）(n&lt;=39)。</p>
</blockquote>
<p><strong>解法一思路：</strong><br>直接根据数学公式<code>f(n) = f(n - 1) + f(n - 2)</code>，截至条件是当<code>n = 1, f(n) = 1</code>，<code>n = 0, f(0) = 0</code>。利用<strong>递归法</strong>进行求解，这种方法时间复杂度很大，为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line">        else:</span><br><span class="line">            return self.Fibonacci(n-1) + self.Fibonacci(n-2)</span><br></pre></td></tr></table></figure>

<p><strong>解法二思路：</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        n1, n2, n3 &#x3D; 0, 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            n3 &#x3D; n1 + n2</span><br><span class="line">            n1 &#x3D; n2</span><br><span class="line">            n2 &#x3D; n3</span><br><span class="line"></span><br><span class="line">        return n3</span><br></pre></td></tr></table></figure>
<p><strong>解法三思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution3:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        sum, one &#x3D; 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            sum &#x3D; sum + one</span><br><span class="line">            one &#x3D; sum - one</span><br><span class="line"></span><br><span class="line">        return sum</span><br></pre></td></tr></table></figure>

<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Fibonacci(8))</span><br><span class="line">    print(Solution2().Fibonacci(8))</span><br><span class="line">    print(Solution3().Fibonacci(8))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br></pre></td></tr></table></figure>
<h3 id="JZ48-不用加减乘除做加法"><a href="#JZ48-不用加减乘除做加法" class="headerlink" title="JZ48 不用加减乘除做加法"></a>JZ48 不用加减乘除做加法</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Add(self, num1, num2):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
</search>
