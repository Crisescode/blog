<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NLP（1）文本分类知识梳理</title>
    <url>/blog/2020/06/27/NLP%EF%BC%881%EF%BC%89%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>NLP</category>
        <category>文本分类</category>
      </categories>
      <tags>
        <tag>文本分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之函数式编程模块（1）</title>
    <url>/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="一、编程方式介绍"><a href="#一、编程方式介绍" class="headerlink" title="一、编程方式介绍"></a>一、编程方式介绍</h2><p>一般编程语言支持通过以下几种方式来解决具体的问题：</p>
<ul>
<li>大多数的编程语言都是<strong>过程式</strong>的，也就是我们常说的面向过程的编程方式。而所谓程序是指令的列表，告诉计算机如何处理程序的输入。C、Pascal甚至Unix shell都是过程式语言。</li>
<li>然后有一些编程语言是<strong>声明式</strong>的，主要是你需要编写一个用来描述待解决问题的说明，然后这个语言的具体实现会指明怎样高效的进行计算并解决问题。SQL 可能是你最熟悉的声明式语言了。 一个 SQL 查询语句描述了你想要检索的数据集，并且 SQL 引擎会决定是扫描整张表还是使用索引，应该先执行哪些子句等等。</li>
<li><strong>面向对象</strong>编程语言会操作一组对象。其中对象拥有内部状态，并能够以某种方式支持请求和修改这个内部状态的方法。Smalltalk 和 Java 都是面向对象的语言。C++ 和 Python 支持面向对象编程，但并不强制使用面向对象特性。</li>
<li>而<strong>函数式</strong>编程则是将一个问题分解成一系列函数。理想情况下，函数只接受输入并产生输出，没有任何内部状态会影响为给定输入产生的输出。众所周知的函数式语言包括ML家族(标准ML、OCaml和其他变体)和Haskell。</li>
</ul>
<a id="more"></a>

<p>一般语言设计者在设计语言时，会选择侧重强调一种特定的编程方式，但这会让以不同方式来编写程序变得困难。因此有些语言就被设计成多范式语言，用以支持以上几种不同的编程方式。其中<strong>Lisp，C++ 和 Python 都是多范式语言；使用这些语言，你可以编写主要为过程式，面向对象或者函数式的程序和函数库。</strong>在大型程序中，不同的部分可能会采用不同的方式编写；比如 GUI 可能是面向对象的而处理逻辑则是过程式或者函数式。</p>
<p>这篇文章主要是来讲解函数式编程，因此接下来主要围绕函数式编程进行展开。</p>
<h2 id="二、函数式编程"><a href="#二、函数式编程" class="headerlink" title="二、函数式编程"></a>二、函数式编程</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>函数式编程：即为给定输入，输入会流经一系列函数，每个函数接收输入并输出结果。并且这个过程，在每个函数内部并不会修改全局变量或者有其他副作用。函数式编程允许把函数本身作为参数传入另一个函数，还允许返回一个函数。</p>
<h3 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a>2.2 特点</h3><p>函数式风格有其理论和实践上的优点：</p>
<ul>
<li>形式证明</li>
<li>模块化</li>
<li>组合性</li>
<li>易于调试和测试</li>
</ul>
<h2 id="三、函数式编程实践"><a href="#三、函数式编程实践" class="headerlink" title="三、函数式编程实践"></a>三、函数式编程实践</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>高级语法</tag>
      </tags>
  </entry>
  <entry>
    <title>My first post</title>
    <url>/blog/2020/06/18/My-first-post/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Python之函数式编程模块（2）</title>
    <url>/blog/2020/06/19/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>这篇文章主要是讲解一些函数式编程常用的模块，比如：<code>itertools</code>, <code>functools</code>以及<code>operator</code>。</p>
<h2 id="一、itertools-–用以创建迭代器的模块"><a href="#一、itertools-–用以创建迭代器的模块" class="headerlink" title="一、itertools –用以创建迭代器的模块"></a>一、itertools –用以创建迭代器的模块</h2><a id="more"></a>

<h2 id="二、functools-–-高阶函数可调用对象上的操作"><a href="#二、functools-–-高阶函数可调用对象上的操作" class="headerlink" title="二、functools – 高阶函数可调用对象上的操作"></a>二、functools – 高阶函数可调用对象上的操作</h2><h2 id="三、operator-–-标准运算符替代函数"><a href="#三、operator-–-标准运算符替代函数" class="headerlink" title="三、operator – 标准运算符替代函数"></a>三、operator – 标准运算符替代函数</h2><p>在函数式编程中，我们经常需要把算术运算符当作函数使用，因此可以借助operator模块。operator 模块提供了一套与Python的内置运算符对应的高效率函数。例如，operator.add(x, y) 与表达式 x+y 相同。</p>
<p>operator 模块为多个算术运算符提供了对应的函数，从而避免编写<br><code>lambda a, b: a * b</code> 这种平凡的匿名函数。这两种做法具体如下：</p>
<ul>
<li>使用<code>lambda a, b: a * b</code>匿名函数来计算阶乘：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def fact(n):</span><br><span class="line">...     return reduce(mul, range(1, n+1))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>operator.mul</code>函数来计算阶乘：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; def fact(n):</span><br><span class="line">...     return reduce(mul, range(1, n+1))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure>

<p>operator 模块中还有一类函数，能替代从系列中取出元素或读取对象属性的lambda表达式：</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>高级语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2020/06/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>剑指offer 第三天</title>
    <url>/blog/2020/07/08/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ11-二进制中1的个数"><a href="#JZ11-二进制中1的个数" class="headerlink" title="JZ11 二进制中1的个数"></a>JZ11 二进制中1的个数</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def NumberOf1(self, n):</span><br><span class="line">    # write code here</span><br><span class="line">    count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    if n &lt; 0:</span><br><span class="line">        n &#x3D; n &amp; 0b11111111111111111111111111111111</span><br><span class="line"></span><br><span class="line">    while n !&#x3D; 0:</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        n &#x3D; n &amp; (n - 1)</span><br><span class="line"></span><br><span class="line">    return count</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().NumberOf1(-11))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 30</span><br></pre></td></tr></table></figure>

<h3 id="JZ27-字符串的排列"><a href="#JZ27-字符串的排列" class="headerlink" title="JZ27 字符串的排列"></a>JZ27 字符串的排列</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
</blockquote>
<blockquote>
<p>输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Permutation(self, ss):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="JZ47-求1-2-3-…-n"><a href="#JZ47-求1-2-3-…-n" class="headerlink" title="JZ47 求1 + 2 + 3 + … + n"></a>JZ47 求1 + 2 + 3 + … + n</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; n</span><br><span class="line">        try:</span><br><span class="line">            res % n</span><br><span class="line">            res +&#x3D; self.Sum_Solution(n - 1)</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution2:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; n</span><br><span class="line">        tmp &#x3D; (res and self.Sum_Solution(n - 1))</span><br><span class="line">        res +&#x3D; tmp</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Sum_Solution(5))</span><br><span class="line">    print(Solution2().Sum_Solution(6))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 15</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<h3 id="JZ51-构建乘积数组"><a href="#JZ51-构建乘积数组" class="headerlink" title="JZ51 构建乘积数组"></a>JZ51 构建乘积数组</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def multiply(self, A):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p><strong>代码测试：</strong></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第一天</title>
    <url>/blog/2020/07/06/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ16-合并两个排序的链表"><a href="#JZ16-合并两个排序的链表" class="headerlink" title="JZ16 合并两个排序的链表"></a>JZ16 合并两个排序的链表</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<p><strong>解法一思路：</strong><br>使用迭代的方法。先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。</p>
<p>然后初始化一个新链表，依次比较两个有序链表的值，哪个链表的值较小，则新链表的指针指向该值。继续循环，依次比较，最终返回单调递增的新链表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Solution2:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead1 is None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 is None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        node &#x3D; sorted_node &#x3D; ListNode(0)</span><br><span class="line"></span><br><span class="line">        while pHead1 and pHead2:</span><br><span class="line">            if pHead1.val &lt; pHead2.val:</span><br><span class="line">                node.next &#x3D; pHead1</span><br><span class="line">                pHead1 &#x3D; pHead1.next</span><br><span class="line">            else:</span><br><span class="line">                node.next &#x3D; pHead2</span><br><span class="line">                pHead2 &#x3D; pHead2.next</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">        if pHead1 or pHead2:</span><br><span class="line">            node.next &#x3D; pHead1 or pHead2</span><br><span class="line"></span><br><span class="line">        return sorted_node.next</span><br><span class="line"></span><br><span class="line">    def travel_list(self, node):</span><br><span class="line">        while node is not None:</span><br><span class="line">            print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            node &#x3D; node.next</span><br></pre></td></tr></table></figure>
<p><strong>解法二思路：</strong><br>使用递归的方法。大体思路同上，先判断临界情况，依次判断输入的两个链表是否为空指针，如果有其中一个为空指针链表，则返回另一个有序的链表。</p>
<p>然后依次比较两个有序链表的值，哪个链表的值较小，则将该节点赋值给新链表。使用递归，直至其中一个链表为None，最终返回和并得到的单调递增链表。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line">        # write code here</span><br><span class="line">        if pHead1 is None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 is None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        if pHead1.val &lt; pHead2.val:</span><br><span class="line">            sorted_list &#x3D; pHead1</span><br><span class="line">            sorted_list.next &#x3D; self.Merge(pHead1.next, pHead2)</span><br><span class="line">        else:</span><br><span class="line">            sorted_list &#x3D; pHead2</span><br><span class="line">            sorted_list.next &#x3D; self.Merge(pHead1, pHead2.next)</span><br><span class="line"></span><br><span class="line">        return sorted_list</span><br><span class="line"></span><br><span class="line">    def travel_list(self, node):</span><br><span class="line">        while node is not None:</span><br><span class="line">            print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            node &#x3D; node.next</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    node_1 &#x3D; ListNode(0)</span><br><span class="line">    node_1.next &#x3D; ListNode(4)</span><br><span class="line">    node_1.next.next &#x3D; ListNode(10)</span><br><span class="line">    node_2 &#x3D; ListNode(2)</span><br><span class="line">    node_2.next &#x3D; ListNode(3)</span><br><span class="line">    node_2.next.next &#x3D; ListNode(12)</span><br><span class="line">    solu_1 &#x3D; Solution()</span><br><span class="line">    # print(solu_1.travel_list(solu_1.Merge(node_1, node_2)))</span><br><span class="line">    solu_2 &#x3D; Solution2()</span><br><span class="line">    print(solu_2.travel_list(solu_2.Merge(node_1, node_2)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 2 3 4 10 12 None</span><br></pre></td></tr></table></figure>

<h3 id="JZ14-链表中倒数第k个结点"><a href="#JZ14-链表中倒数第k个结点" class="headerlink" title="JZ14 链表中倒数第k个结点"></a>JZ14 链表中倒数第k个结点</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p><strong>解法一思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lass ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 时间复杂度： O(n)</span><br><span class="line">    # 空间复杂度： O(n)</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; []</span><br><span class="line"></span><br><span class="line">        while head is not None:</span><br><span class="line">            res.insert(0, head.val)</span><br><span class="line">            head &#x3D; head.next</span><br><span class="line"></span><br><span class="line">        if len(res) &lt; k or k &lt; 1:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        return res[k-1]</span><br><span class="line"></span><br><span class="line">    def travel_listNode(self, listNode):</span><br><span class="line">        while listNode:</span><br><span class="line">            print(listNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br></pre></td></tr></table></figure>

<p><strong>解法二思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    # 时间复杂度： O(n)</span><br><span class="line">    # 空间复杂度： O(1)</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        # write code here</span><br><span class="line">        if k &lt; 0 or head is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        slow, fast &#x3D; head, head</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        while fast.next is not None:</span><br><span class="line">            fast &#x3D; fast.next</span><br><span class="line">            if count &gt;&#x3D; k - 1:</span><br><span class="line">                slow &#x3D; slow.next</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        if count &gt;&#x3D; k - 1:</span><br><span class="line">            return slow.val</span><br><span class="line"></span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(4) </span><br><span class="line"></span><br><span class="line">    print(Solution().travel_listNode(curr))</span><br><span class="line">    print(Solution().FindKthToTail(curr, 5))</span><br><span class="line">    print(Solution2().FindKthToTail(curr, 5))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 1 2 3 4 None</span><br><span class="line">&gt;&gt;&gt; 0</span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure>
<h3 id="JZ15-反转链表"><a href="#JZ15-反转链表" class="headerlink" title="JZ15 反转链表"></a>JZ15 反转链表</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回ListNode</span><br><span class="line">    def ReverseList(self, pHead):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pHead or pHead.next is None:</span><br><span class="line">            return pHead</span><br><span class="line"></span><br><span class="line">        curr, prev &#x3D; pHead, None</span><br><span class="line">        while curr:</span><br><span class="line">            tmp &#x3D; curr.next</span><br><span class="line">            curr.next &#x3D; prev</span><br><span class="line">            prev &#x3D; curr</span><br><span class="line">            curr &#x3D; tmp</span><br><span class="line"></span><br><span class="line">        return prev</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    # print(head)</span><br><span class="line">    print(curr)</span><br><span class="line"></span><br><span class="line">    res &#x3D; Solution().ReverseList(curr)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>

<h3 id="JZ13-从尾到头打印链表"><a href="#JZ13-从尾到头打印链表" class="headerlink" title="JZ13 从尾到头打印链表"></a>JZ13 从尾到头打印链表</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</span><br><span class="line">    def printListFromTailToHead(self, listNode):</span><br><span class="line">        # write code here</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while listNode:</span><br><span class="line">            res.insert(0, listNode.val)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def travel_listNode(self, listNode):</span><br><span class="line">        while listNode:</span><br><span class="line">            print(listNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            listNode &#x3D; listNode.next</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    curr &#x3D; head &#x3D; ListNode(0)</span><br><span class="line">    head.next &#x3D; ListNode(1)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(2)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(3)</span><br><span class="line">    head &#x3D; head.next</span><br><span class="line">    head.next &#x3D; ListNode(4)</span><br><span class="line"></span><br><span class="line">    print(Solution().travel_listNode(curr))</span><br><span class="line">    print(Solution().printListFromTailToHead(curr))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第二天</title>
    <url>/blog/2020/07/07/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ49-把字符串转化成整数"><a href="#JZ49-把字符串转化成整数" class="headerlink" title="JZ49 把字符串转化成整数"></a>JZ49 把字符串转化成整数</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入描述：<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述：<br>如果是合法的数值表达则返回该数字，否则返回0</p>
</blockquote>
<blockquote>
<p>示例：<br>输入：<br>+2147483647<br>1a33<br>输出：<br>2147483647<br>0</p>
</blockquote>
<p><strong>解法思路：</strong><br>使用了一个很巧妙的方法，用一个字典将字符串”0”-“9”与数字0 - 9做一个映射，然后再用数学上计算一个数字的公式得出这个数。比如：<code>123 = (1 * 10 + 2 ) * 10 + 3</code>。需要注意字符串开头的正负号，从而判断得到的数字是整数还是负数。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def StrToInt(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(s) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        str2num &#x3D; &#123;</span><br><span class="line">            &quot;0&quot;: 0, &quot;1&quot;: 1, &quot;2&quot;: 2, &quot;3&quot;: 3, &quot;4&quot;: 4,</span><br><span class="line">            &quot;5&quot;: 5, &quot;6&quot;: 6, &quot;7&quot;: 7, &quot;8&quot;: 8, &quot;9&quot;: 9,</span><br><span class="line">            &quot;+&quot;: 1, &quot;-&quot;: -1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum &#x3D; 0</span><br><span class="line">        sign &#x3D; 1</span><br><span class="line">        for c in s:</span><br><span class="line">            if c in str2num:</span><br><span class="line">                if c &#x3D;&#x3D; &quot;+&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;+&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                if c &#x3D;&#x3D; &quot;-&quot;:</span><br><span class="line">                    sign &#x3D; str2num[&quot;-&quot;]</span><br><span class="line">                    continue</span><br><span class="line">                sum &#x3D; sum * 10 + str2num[c]</span><br><span class="line">            else:</span><br><span class="line">                sum &#x3D; 0</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return sum * sign</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    s &#x3D; &quot;-98210&quot;</span><br><span class="line">    print(Solution().StrToInt(s))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 98210</span><br></pre></td></tr></table></figure>

<h3 id="JZ7-斐波那契数列"><a href="#JZ7-斐波那契数列" class="headerlink" title="JZ7 斐波那契数列"></a>JZ7 斐波那契数列</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）(n&lt;=39)。</p>
</blockquote>
<p><strong>解法一思路：</strong><br>直接根据数学公式<code>f(n) = f(n - 1) + f(n - 2)</code>，截至条件是当<code>n = 1, f(n) = 1</code>，<code>n = 0, f(0) = 0</code>。利用<strong>递归法</strong>进行求解，这种方法时间复杂度很大，为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line">        else:</span><br><span class="line">            return self.Fibonacci(n-1) + self.Fibonacci(n-2)</span><br></pre></td></tr></table></figure>

<p><strong>解法二思路：</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution2:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        n1, n2, n3 &#x3D; 0, 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            n3 &#x3D; n1 + n2</span><br><span class="line">            n1 &#x3D; n2</span><br><span class="line">            n2 &#x3D; n3</span><br><span class="line"></span><br><span class="line">        return n3</span><br></pre></td></tr></table></figure>
<p><strong>解法三思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution3:</span><br><span class="line">    def Fibonacci(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;&#x3D; 1:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        sum, one &#x3D; 1, 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            sum &#x3D; sum + one</span><br><span class="line">            one &#x3D; sum - one</span><br><span class="line"></span><br><span class="line">        return sum</span><br></pre></td></tr></table></figure>

<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().Fibonacci(8))</span><br><span class="line">    print(Solution2().Fibonacci(8))</span><br><span class="line">    print(Solution3().Fibonacci(8))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br><span class="line">&gt;&gt;&gt; 21</span><br></pre></td></tr></table></figure>
<h3 id="JZ48-不用加减乘除做加法"><a href="#JZ48-不用加减乘除做加法" class="headerlink" title="JZ48 不用加减乘除做加法"></a>JZ48 不用加减乘除做加法</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Add(self, num1, num2):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第四天</title>
    <url>/blog/2020/07/11/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ4-重建二叉树"><a href="#JZ4-重建二叉树" class="headerlink" title="JZ4 重建二叉树"></a>JZ4 重建二叉树</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 [1,2,4,7,3,5,6,8] 和中序遍历序列 [4,7,2,1,5,3,8,6] ，则重建二叉树并返回。</p>
</blockquote>
<p><strong>解法思路：</strong><br>使用递归的方法求解。这道题需要对二叉树的性质比较了解，需要熟悉二叉树的几种遍历方式。</p>
<p><strong>前序遍历是先遍历根节点，然后遍历左节点，最后遍历右节点（根左右）</strong></p>
<p><strong>中序遍历是先遍历左节点，然后遍历根节点，最后遍历右节点（左根右）</strong></p>
<p><strong>后序遍历是先遍历左节点，然后遍历右节点，最后遍历根节点（根左右）</strong></p>
<p>本题给定前序遍历以及中序遍历的序列，可以知道前序遍历第一个值一定是根节点。而根节点在中序遍历中会把左右子树分成两半。因此本题的关键是找到根节点，然后将左右子树依次递归重建得到二叉树。</p>
<p>使用递归是需要结束条件的，当前序或中序遍历序列为<code>None</code>时，便可推出递归，得到二叉树。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回构造的TreeNode根节点</span><br><span class="line">    def reConstructBinaryTree(self, pre, tin):</span><br><span class="line">        if not pre or not tin:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        root &#x3D; TreeNode(pre.pop(0))</span><br><span class="line">        index &#x3D; tin.index(root.val)</span><br><span class="line"></span><br><span class="line">        root.left &#x3D; self.reConstructBinaryTree(pre, tin[:index])</span><br><span class="line">        root.right &#x3D; self.reConstructBinaryTree(pre, tin[index + 1:])</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br><span class="line"></span><br><span class="line">    def InOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line">        self.InOrder(root.left)</span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.InOrder(root.right)</span><br><span class="line"></span><br><span class="line">    def BackOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line">        self.BackOrder(root.left)</span><br><span class="line">        self.BackOrder(root.right)</span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br></pre></td></tr></table></figure>
<p>本题只需写好<code>reConstructBinaryTree</code>这个方法，上面代码其他三个函数是用来前序、中序以及后序遍历重建得到二叉树的，以方便大家调试。<br><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    pre &#x3D; [1, 2, 4, 7, 3, 5, 6, 8]</span><br><span class="line">    tin &#x3D; [4, 7, 2, 1, 5, 3, 8, 6]</span><br><span class="line"></span><br><span class="line">    reTree &#x3D; Solution().reConstructBinaryTree(pre, tin)</span><br><span class="line">    print(&quot;前序遍历：&quot;)</span><br><span class="line">    Solution().preOrder(reTree)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    print(&quot;中序遍历：&quot;)</span><br><span class="line">    Solution().InOrder(reTree)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    print(&quot;后序遍历：&quot;)</span><br><span class="line">    Solution().BackOrder(reTree)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 前序遍历：</span><br><span class="line">1 2 4 7 3 5 6 8 </span><br><span class="line"></span><br><span class="line">中序遍历：</span><br><span class="line">4 7 2 1 5 3 8 6 </span><br><span class="line"></span><br><span class="line">后序遍历：</span><br><span class="line">7 4 2 5 8 6 3 1</span><br></pre></td></tr></table></figure>

<h3 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。<br> 二叉树的镜像定义如下：</p>
</blockquote>
<pre><code> 源二叉树
    8
   /  \
  6   10
 / \  / \
5  7 9 11

镜像二叉树
     8
   /  \
  10   6
 / \  / \
11 9 7  5</code></pre><p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回镜像树的根节点</span><br><span class="line">    def Mirror(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        root.left, root.right &#x3D; \</span><br><span class="line">            self.Mirror(root.right), self.Mirror(root.left)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    tree1 &#x3D; TreeNode(8)</span><br><span class="line">    tree1.left &#x3D; TreeNode(6)</span><br><span class="line">    tree1.right &#x3D; TreeNode(10)</span><br><span class="line">    tree1.left.left &#x3D; TreeNode(5)</span><br><span class="line">    tree1.left.right &#x3D; TreeNode(7)</span><br><span class="line">    tree1.right.left &#x3D; TreeNode(9)</span><br><span class="line">    tree1.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    invert_tree &#x3D; Solution().Mirror(tree1)</span><br><span class="line">    print(Solution().preOrder(invert_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 8 10 11 9 6 7 5 None</span><br></pre></td></tr></table></figure>
<h3 id="JZ23-二叉搜索树的后序遍历"><a href="#JZ23-二叉搜索树的后序遍历" class="headerlink" title="JZ23 二叉搜索树的后序遍历"></a>JZ23 二叉搜索树的后序遍历</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(sequence) &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        root &#x3D; sequence[-1]</span><br><span class="line">        for index, value in enumerate(sequence):</span><br><span class="line">            if value &gt; root:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for value in sequence[index: -1]:</span><br><span class="line">            if value &lt; root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">        left &#x3D; True</span><br><span class="line">        if index &gt; 0:</span><br><span class="line">            left &#x3D; self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line"></span><br><span class="line">        right &#x3D; True</span><br><span class="line">        if index &lt; len(sequence) - 1:</span><br><span class="line">            right &#x3D; self.VerifySquenceOfBST(sequence[index: -1])</span><br><span class="line"></span><br><span class="line">        return left and right</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    is_binary_tree &#x3D; [1, 3, 5, 9, 12, 10, 7]</span><br><span class="line">    print(Solution().VerifySquenceOfBST(is_binary_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure>

<h3 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<blockquote>
<p>输入：8<br>输出：18 </p>
</blockquote>
<p><strong>解法思路：</strong></p>
<p><strong>代码测试：</strong></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第六天</title>
    <url>/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AD%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ6-旋转数组的最小数字"><a href="#JZ6-旋转数组的最小数字" class="headerlink" title="JZ6 旋转数组的最小数字"></a>JZ6 旋转数组的最小数字</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p><strong>解法思路：</strong><br>这题主要是考察二分查找。<strong>二分查找</strong>，又叫折半查找。它的前提是线性表中的数据必须是有序的，线性表必须采用顺序存储。主要思想是：在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找；不断重复上述过程，直至查找成功，或所有查找区域无记录，查找失败为止。</p>
<p>上面介绍了二分查找的主要思路，而本题难点在于找到中间值与谁进行比较？ 再认真审下题，给定的是非递减排序的数组，也就是“平序”或升序。例如：<code>[1, 2, 3, 3, 3, 5, 6]</code>（“平序”），<code>[1, 2, 3, 4, 5, 6]</code>（升序）。然后再做旋转得到旋转数组<code>[3, 3, 5, 6, 1, 2, 3]</code>，<code>[4, 5, 6, 1, 2, 3]</code>，可以确定的是旋转后的数组<code>nums[0] &gt;= nums[-1]</code>恒成立。</p>
<p>这样也就得到了<code>nums[mid]</code>与哪个值进行比较了，当然是：</p>
<ul>
<li><code>nums[mid] &gt; nums[left]</code> , 这个时候 <code>left = mid + 1</code></li>
<li><code>nums[mid] &lt; nums[right]</code>, 这个时候 <code>right = mid</code></li>
<li><code>nums[mid] = nums[right]</code>, 这个时候 <code>left += 1</code></li>
</ul>
<p>这里可以一定意义上认为<code>nums[left]</code>与<code>nums[right]</code>近似相等，这样便于理解。</p>
<blockquote>
<p>注: 以上<code>nums</code>代表传入的旋转数组，<code>left</code>指数组的第一个数，<code>right</code>指数组末尾的数，<code>mid</code>指数组中间位置的数。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(rotateArray) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; len(rotateArray) - 1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            if rotateArray[left] &lt; rotateArray[right]:</span><br><span class="line">                return rotateArray[left]</span><br><span class="line"></span><br><span class="line">            mid &#x3D; (left + right) &#x2F;&#x2F; 2</span><br><span class="line">            if rotateArray[mid] &gt; rotateArray[left]:</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            elif rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">            else:</span><br><span class="line">                left +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return rotateArray[left]</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().minNumberInRotateArray([1, 0, 1, 1, 1]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0</span><br></pre></td></tr></table></figure>

<h3 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。<br> 二叉树的镜像定义如下：</p>
</blockquote>
<pre><code> 源二叉树
    8
   /  \
  6   10
 / \  / \
5  7 9 11

镜像二叉树
     8
   /  \
  10   6
 / \  / \
11 9 7  5</code></pre><p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回镜像树的根节点</span><br><span class="line">    def Mirror(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        root.left, root.right &#x3D; \</span><br><span class="line">            self.Mirror(root.right), self.Mirror(root.left)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def preOrder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        print(root.val, end&#x3D;&#39; &#39;)</span><br><span class="line">        self.preOrder(root.left)</span><br><span class="line">        self.preOrder(root.right)</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    tree1 &#x3D; TreeNode(8)</span><br><span class="line">    tree1.left &#x3D; TreeNode(6)</span><br><span class="line">    tree1.right &#x3D; TreeNode(10)</span><br><span class="line">    tree1.left.left &#x3D; TreeNode(5)</span><br><span class="line">    tree1.left.right &#x3D; TreeNode(7)</span><br><span class="line">    tree1.right.left &#x3D; TreeNode(9)</span><br><span class="line">    tree1.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    invert_tree &#x3D; Solution().Mirror(tree1)</span><br><span class="line">    print(Solution().preOrder(invert_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 8 10 11 9 6 7 5 None</span><br></pre></td></tr></table></figure>
<h3 id="JZ23-二叉搜索树的后序遍历"><a href="#JZ23-二叉搜索树的后序遍历" class="headerlink" title="JZ23 二叉搜索树的后序遍历"></a>JZ23 二叉搜索树的后序遍历</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(sequence) &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        root &#x3D; sequence[-1]</span><br><span class="line">        for index, value in enumerate(sequence):</span><br><span class="line">            if value &gt; root:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for value in sequence[index: -1]:</span><br><span class="line">            if value &lt; root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">        left &#x3D; True</span><br><span class="line">        if index &gt; 0:</span><br><span class="line">            left &#x3D; self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line"></span><br><span class="line">        right &#x3D; True</span><br><span class="line">        if index &lt; len(sequence) - 1:</span><br><span class="line">            right &#x3D; self.VerifySquenceOfBST(sequence[index: -1])</span><br><span class="line"></span><br><span class="line">        return left and right</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    is_binary_tree &#x3D; [1, 3, 5, 9, 12, 10, 7]</span><br><span class="line">    print(Solution().VerifySquenceOfBST(is_binary_tree))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure>

<h3 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<blockquote>
<p>输入：8<br>输出：18 </p>
</blockquote>
<p><strong>解法思路：</strong></p>
<p><strong>代码测试：</strong></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第五天</title>
    <url>/blog/2020/07/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ8-跳台阶"><a href="#JZ8-跳台阶" class="headerlink" title="JZ8 跳台阶"></a>JZ8 跳台阶</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        res, counter &#x3D; 1, 0</span><br><span class="line">        for i in range(1, number + 1):</span><br><span class="line">            res &#x3D; res + counter</span><br><span class="line">            counter &#x3D; res - counter</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().jumpFloor(3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3</span><br></pre></td></tr></table></figure>

<h3 id="JZ9-变态跳台阶"><a href="#JZ9-变态跳台阶" class="headerlink" title="JZ9 变态跳台阶"></a>JZ9 变态跳台阶</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jumpFloor(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        curr, prev &#x3D; 1, 1</span><br><span class="line">        for i in range(1, number):</span><br><span class="line">            curr &#x3D; 2 * prev</span><br><span class="line">            prev &#x3D; curr</span><br><span class="line"></span><br><span class="line">        return curr</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().jumpFloor(3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 4</span><br></pre></td></tr></table></figure>
<h3 id="JZ10-矩形覆盖"><a href="#JZ10-矩形覆盖" class="headerlink" title="JZ10 矩形覆盖"></a>JZ10 矩形覆盖</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rectCover(self, number):</span><br><span class="line">        # write code here</span><br><span class="line">        if number &lt;&#x3D; 2:</span><br><span class="line">            return number</span><br><span class="line"></span><br><span class="line">        res, counter &#x3D; 1, 0</span><br><span class="line">        for i in range(1, number + 1):</span><br><span class="line">            res &#x3D; res + counter</span><br><span class="line">            counter &#x3D; res - counter</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().rectCover(4))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 5</span><br></pre></td></tr></table></figure>

<h3 id="JZ21-栈的压入、弹出序列"><a href="#JZ21-栈的压入、弹出序列" class="headerlink" title="JZ21 栈的压入、弹出序列"></a>JZ21 栈的压入、弹出序列</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。<br>（注意：这两个序列的长度是相等的）</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def IsPopOrder(self, pushV, popV):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p><strong>代码测试：</strong></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第七天</title>
    <url>/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ19-顺时针打印矩阵"><a href="#JZ19-顺时针打印矩阵" class="headerlink" title="JZ19 顺时针打印矩阵"></a>JZ19 顺时针打印矩阵</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<p><strong>解法思路：</strong><br>这道题刚开始自己一看，就是想着设置一些索引位置，按照索引位置打印来打印不就行了。后来再认真读题，发现它输入的二维矩阵大小是变化的，不是固定大小，才发现自己的想法太<code>native</code>。</p>
<p>看了下讨论区，发现只是需要确定几个固定位置的索引值，便可以不管输入矩阵的大小，自适应的便能够确定顺时针打印每个位置的索引，然后再根据这个索引来打印矩阵就行，还真是巧妙。其实在确定好几个顶点的位置，也就相当于确定了方向，然后不管是顺时针还是逆时针，下次都可以方便的解题了。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # matrix类型为二维列表，需要返回列表</span><br><span class="line">    def printMatrix(self, matrix):</span><br><span class="line">        # write code here</span><br><span class="line">        top &#x3D; 0</span><br><span class="line">        bottom &#x3D; len(matrix)</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; len(matrix[0])</span><br><span class="line"></span><br><span class="line">        res &#x3D; []</span><br><span class="line">        # 判断是否越界</span><br><span class="line">        while top &lt; bottom and left &lt; right:</span><br><span class="line">            # 最上面一行，需向右打印</span><br><span class="line">            res.extend([matrix[top][c] for c in range(left, right)])</span><br><span class="line">            # 最右边一行，需向下打印</span><br><span class="line">            res.extend([matrix[r][right - 1] for r in range(top + 1, bottom)])</span><br><span class="line">            # 最下面一行，需向左打印</span><br><span class="line">            if bottom - top &gt; 1:</span><br><span class="line">                res.extend([matrix[bottom - 1][c] for c in range(right - 2, left, -1)]) # 注意需要将右边那个值去除掉</span><br><span class="line">            # 最左边一行，需向上打印</span><br><span class="line">            if right - left &gt; 1:</span><br><span class="line">                res.extend([matrix[r][left] for r in range(bottom - 1, top, -1)])</span><br><span class="line"></span><br><span class="line">            top +&#x3D; 1</span><br><span class="line">            bottom -&#x3D; 1</span><br><span class="line">            left +&#x3D; 1</span><br><span class="line">            right -&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    num &#x3D; 1</span><br><span class="line">    matrix &#x3D; [[0 for i in range(4)] for j in range(4)]</span><br><span class="line">    for i in range(4):</span><br><span class="line">        for j in range(4):</span><br><span class="line">            matrix[i][j] &#x3D; num</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    print(Solution().printMatrix(matrix))</span><br><span class="line">    print(Solution().printMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]</span><br><span class="line">[1, 2, 4, 6, 8, 10, 9, 7, 5, 3]</span><br></pre></td></tr></table></figure>

<h3 id="JZ38-二叉树的深度"><a href="#JZ38-二叉树的深度" class="headerlink" title="JZ38 二叉树的深度"></a>JZ38 二叉树的深度</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        x &#x3D; pRoot</span><br><span class="line"></span><br><span class="line">        left &#x3D; self.TreeDepth(pRoot.left)</span><br><span class="line">        right &#x3D; self.TreeDepth(pRoot.right)</span><br><span class="line"></span><br><span class="line">        return max(left, right) + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution2:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot is None:</span><br><span class="line">            return 0</span><br><span class="line">        q &#x3D; []</span><br><span class="line">        depth &#x3D; 0</span><br><span class="line">        q.append(pRoot)</span><br><span class="line">        while len(q):  # 队列为空时说明没有下一层</span><br><span class="line">            length &#x3D; len(q)</span><br><span class="line">            for i in range(length):  # 遍历层的每个节点看是否有子节点有则加入</span><br><span class="line">                current &#x3D; q.pop(0)  # current为当前遍历到的层中节点，取出，注意pop(-1)为默认，这里要pop(0),取出第一个，先入先出</span><br><span class="line">                if current.left:</span><br><span class="line">                    q.append(current.left)</span><br><span class="line">                if current.right:</span><br><span class="line">                    q.append(current.right)</span><br><span class="line">            depth +&#x3D; 1</span><br><span class="line">        return depth</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="JZ60-把二叉树打印成多行"><a href="#JZ60-把二叉树打印成多行" class="headerlink" title="JZ60 把二叉树打印成多行"></a>JZ60 把二叉树打印成多行</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回二维列表[[1,2],[4,5]]</span><br><span class="line">    def Print(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        node_queue &#x3D; [pRoot]</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while node_queue:</span><br><span class="line">            val &#x3D; []</span><br><span class="line">            length &#x3D; len(node_queue)</span><br><span class="line">            for i in range(length):</span><br><span class="line">                current &#x3D; node_queue.pop(0)</span><br><span class="line">                val.append(current.val)</span><br><span class="line"></span><br><span class="line">                if current.left:</span><br><span class="line">                    node_queue.append(current.left)</span><br><span class="line">                if current.right:</span><br><span class="line">                    node_queue.append(current.right)</span><br><span class="line"></span><br><span class="line">            res.append(val)</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(8)</span><br><span class="line">    root.left &#x3D; TreeNode(6)</span><br><span class="line">    root.right &#x3D; TreeNode(10)</span><br><span class="line">    root.left.left &#x3D; TreeNode(5)</span><br><span class="line">    root.left.right &#x3D; TreeNode(7)</span><br><span class="line">    root.right.left &#x3D; TreeNode(9)</span><br><span class="line">    root.right.right &#x3D; TreeNode(11)</span><br><span class="line"></span><br><span class="line">    print(Solution().Print(root))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [[8], [6, 10], [5, 7, 9, 11]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第八天</title>
    <url>/blog/2020/07/20/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AB%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ59-按之字形顺序打印二叉树"><a href="#JZ59-按之字形顺序打印二叉树" class="headerlink" title="JZ59 按之字形顺序打印二叉树"></a>JZ59 按之字形顺序打印二叉树</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<p><strong>解法思路：</strong><br>这道题其实是昨天最后一道题<a href="http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/" target="_blank" rel="noopener"><code>JZ60</code></a>的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度<code>depth</code>进行解题。在每次需要打印的地方，当深度<code>depth</code>对2取余，为0则从左到右打印，为1则反转打印。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def Print(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot is None:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        depth &#x3D; 0</span><br><span class="line">        node_queue &#x3D; [pRoot]</span><br><span class="line">        res &#x3D; []</span><br><span class="line"></span><br><span class="line">        while node_queue:</span><br><span class="line">            val &#x3D; []</span><br><span class="line">            length &#x3D; len(node_queue)</span><br><span class="line">            for i in range(length):</span><br><span class="line">                current &#x3D; node_queue.pop(0)</span><br><span class="line">                val.append(current.val)</span><br><span class="line"></span><br><span class="line">                if current.left:</span><br><span class="line">                    node_queue.append(current.left)</span><br><span class="line"></span><br><span class="line">                if current.right:</span><br><span class="line">                    node_queue.append(current.right)</span><br><span class="line"></span><br><span class="line">            if depth % 2 &#x3D;&#x3D; 0:</span><br><span class="line">                res.append(val)</span><br><span class="line">            else:</span><br><span class="line">                res.append(list(reversed(val)))</span><br><span class="line"></span><br><span class="line">            depth +&#x3D; 1</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().Print(root))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [[0], [2, 1], [3, 4, 5], [6]]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="JZ58-对称的二叉树"><a href="#JZ58-对称的二叉树" class="headerlink" title="JZ58 对称的二叉树"></a>JZ58 对称的二叉树</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<!--more-->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Solution:</span><br><span class="line">    def isSymmetrical(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    num &#x3D; 1</span><br><span class="line">    matrix &#x3D; [[0 for i in range(4)] for j in range(4)]</span><br><span class="line">    for i in range(4):</span><br><span class="line">        for j in range(4):</span><br><span class="line">            matrix[i][j] &#x3D; num</span><br><span class="line">            num +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    print(Solution().printMatrix(matrix))</span><br><span class="line">    print(Solution().printMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]</span><br><span class="line">[1, 2, 4, 6, 8, 10, 9, 7, 5, 3]</span><br></pre></td></tr></table></figure>

<h3 id="JZ38-二叉树的下一个结点"><a href="#JZ38-二叉树的下一个结点" class="headerlink" title="JZ38 二叉树的下一个结点"></a>JZ38 二叉树的下一个结点</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def GetNext(self, pNode):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="JZ38-平衡二叉树"><a href="#JZ38-平衡二叉树" class="headerlink" title="JZ38 平衡二叉树"></a>JZ38 平衡二叉树</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<blockquote>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def IsBalanced_Solution(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    root &#x3D; TreeNode(0)</span><br><span class="line">    root.left &#x3D; TreeNode(1)</span><br><span class="line">    root.right &#x3D; TreeNode(2)</span><br><span class="line">    root.left.left &#x3D; TreeNode(3)</span><br><span class="line">    root.left.right &#x3D; TreeNode(4)</span><br><span class="line">    root.right.left &#x3D; TreeNode(5)</span><br><span class="line">    root.right.left.left &#x3D; TreeNode(6)</span><br><span class="line"></span><br><span class="line">    print(Solution().TreeDepth(root))</span><br><span class="line">    print(Solution2().TreeDepth(root))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第九天</title>
    <url>/blog/2020/07/25/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B9%9D%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ64-滑动窗口的最大值"><a href="#JZ64-滑动窗口的最大值" class="headerlink" title="JZ64 滑动窗口的最大值"></a>JZ64 滑动窗口的最大值</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，<br>{2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
</blockquote>
<p>这道题其实是昨天最后一道题<a href="http://localhost:4000/blog/2020/07/19/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%83%E5%A4%A9/" target="_blank" rel="noopener"><code>JZ60</code></a>的升级版，其实也就是层次遍历二叉树（BFS）。层次遍历思想可以参见上一道题，只是此题需要结合二叉树的深度<code>depth</code>进行解题。在每次需要打印的地方，当深度<code>depth</code>对2取余，为0则从左到右打印，为1则反转打印。</p>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxInWindows(self, num, size):</span><br><span class="line">        # write code here</span><br><span class="line">        if num is None or size &lt;&#x3D; 0:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        max_list &#x3D; []</span><br><span class="line">        for i in range(len(num) - size + 1):</span><br><span class="line">            range_ &#x3D; num[i: i+size]</span><br><span class="line">            max_list.append(max(range_))</span><br><span class="line">        return max_list</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().maxInWindows([2, 3, 4, 2, 6, 2, 5, 1], 2))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [3, 4, 4, 6, 6, 5, 5]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="JZ40-数组中只出现一次的数字"><a href="#JZ40-数组中只出现一次的数字" class="headerlink" title="JZ40 数组中只出现一次的数字"></a>JZ40 数组中只出现一次的数字</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<!--more-->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 返回[a,b] 其中ab是出现一次的两个数字</span><br><span class="line">    def FindNumsAppearOnce(self, array):</span><br><span class="line">        # write code here</span><br><span class="line">        if array is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        hash_map &#x3D; &#123;&#125;</span><br><span class="line">        for num in array:</span><br><span class="line">            if num in hash_map:</span><br><span class="line">                hash_map[num] +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                hash_map[num] &#x3D; 1</span><br><span class="line"></span><br><span class="line">        res &#x3D; [num for num in hash_map.keys() if hash_map[num] &#x3D;&#x3D; 1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(Solution().FindNumsAppearOnce([2, 3, 1, 5, 1, 3, 6, 11, 6, 0, 11, 5]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [2, 0]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第十天</title>
    <url>/blog/2020/07/27/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E5%A4%A9/</url>
    <content><![CDATA[<h3 id="JZ29-最小的K个数"><a href="#JZ29-最小的K个数" class="headerlink" title="JZ29 最小的K个数"></a>JZ29 最小的K个数</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
</blockquote>
<p><strong>解法思路：</strong><br>这题第一印象是直接将列表从小到大进行排序然后返回前K个数即可。所以本题第一种方法就是利用快排然后返回前K个数得到结果，这个方法没什么好说的，只要对快排熟悉即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def GetLeastNumbers_Solution(self, tinput, k):</span><br><span class="line">    # write code here</span><br><span class="line">    if tinput &#x3D;&#x3D; [] or k &lt;&#x3D; 0 or k &gt; len(tinput):</span><br><span class="line">        return []</span><br><span class="line"></span><br><span class="line">    return self.quick_sort(tinput)[:k]</span><br><span class="line"></span><br><span class="line">def quick_sort(self, array):</span><br><span class="line">    if len(array) &lt;&#x3D; 1:</span><br><span class="line">        return array</span><br><span class="line"></span><br><span class="line">    pivot &#x3D; array[0]</span><br><span class="line">    less_pivot &#x3D; [num for num in array if num &lt; pivot]</span><br><span class="line">    more_pivot &#x3D; [num for num in array if num &gt; pivot]</span><br><span class="line"></span><br><span class="line">    return self.quick_sort(less_pivot) + [pivot] + self.quick_sort(more_pivot)</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    array &#x3D; [4, 5, 1, 6, 2, 7, 3, 8]</span><br><span class="line">    print(Solution().GetLeastNumbers_Solution(array, 4))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="JZ28-数组中出现次数超过一半的数字"><a href="#JZ28-数组中出现次数超过一半的数字" class="headerlink" title="JZ28 数组中出现次数超过一半的数字"></a>JZ28 数组中出现次数超过一半的数字</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。<br>由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<p><strong>解法思路：</strong><br>很朴素的做法，利用哈希进行统计出数字出现的次数，然后再与数组的长度的一半进行比较即可得到结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def MoreThanHalfNum_Solution(self, numbers):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(numbers) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        length &#x3D; len(numbers)</span><br><span class="line">        hash_map &#x3D; &#123;&#125;</span><br><span class="line">        for num in numbers:</span><br><span class="line">            if num in hash_map:</span><br><span class="line">                hash_map[num] +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                hash_map[num] &#x3D; 1</span><br><span class="line">        nums &#x3D; [num for num in hash_map.keys() if hash_map[num] &gt; length &#x2F; 2]</span><br><span class="line">        return nums[0] if nums else 0</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    numbers &#x3D; [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">    print(Solution().MoreThanHalfNum_Solution(numbers))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure>

<h3 id="JZ30-连续子数组的最大和"><a href="#JZ30-连续子数组的最大和" class="headerlink" title="JZ30 连续子数组的最大和"></a>JZ30 连续子数组的最大和</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,<br>当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？<br>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，<br>你会不会被他忽悠住？(子向量的长度至少是1)</p>
</blockquote>
<p><strong>解法思路：</strong><br>动态规划方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def FindGreatestSumOfSubArray(self, array):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(array) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        max_num &#x3D; array[0]</span><br><span class="line">        continuous_sum &#x3D; 0</span><br><span class="line">        for num in array:</span><br><span class="line">            if continuous_sum &gt; 0:</span><br><span class="line">                continuous_sum +&#x3D; num</span><br><span class="line">            else:</span><br><span class="line">                continuous_sum &#x3D; num</span><br><span class="line">            max_num &#x3D; max(continuous_sum, max_num)</span><br><span class="line"></span><br><span class="line">        return max_num</span><br></pre></td></tr></table></figure>
<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    array &#x3D; [6, -3, -2, 7, -15, 1, 2, 2]</span><br><span class="line">    print(Solution().FindGreatestSumOfSubArray(array))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; 8</span><br></pre></td></tr></table></figure>
<h3 id="JZ50-数组中重复的数字"><a href="#JZ50-数组中重复的数字" class="headerlink" title="JZ50 数组中重复的数字"></a>JZ50 数组中重复的数字</h3><p><strong>题目描述：</strong></p>
<blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。<br>请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<p><strong>解法思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span><br><span class="line">    # 函数返回True&#x2F;False</span><br><span class="line">    def duplicate(self, numbers, duplication):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(numbers) &#x3D;&#x3D; 0:</span><br><span class="line">            return False, 0</span><br><span class="line">        stack &#x3D; []</span><br><span class="line">        for num in numbers:</span><br><span class="line">            if num &gt; len(numbers) - 1:</span><br><span class="line">                return False, 0</span><br><span class="line">            if num not in stack:</span><br><span class="line">                stack.append(num)</span><br><span class="line">            else:</span><br><span class="line">               duplication.append(num)</span><br><span class="line">               return True, duplication[0]</span><br><span class="line"></span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<p><strong>代码测试：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    # numbers &#x3D; [2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">    numbers &#x3D; [2, 1, 3, 1, 4]</span><br><span class="line">    print(Solution().duplicate(numbers, []))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; (True, 1)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 第十一天</title>
    <url>/blog/2020/07/29/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式训练之PyTorch</title>
    <url>/blog/2020/07/31/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E4%B9%8BPyTorch/</url>
    <content><![CDATA[<p>由于近期来自客户需求，需要部门开发的AI平台支持上 PyTorch 框架的分布式训练，因此自己也是花了大概一周的时间，仔细研究了下 PyTorch 的分布式训练，中间也遇到了不少问题，好在通过查阅相关资料大都解决了，昨天也到客户那已经部署成功了。现将关于 PyTorch 分布式训练知识总结一下，方便大家或自己以后查阅，以下内容如有总结不到位的地方，请大家不吝赐教~</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2>]]></content>
      <categories>
        <category>深度学习框架</category>
      </categories>
      <tags>
        <tag>分布式训练</tag>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>[NLP] 文本摘要之PGN指针生成网络</title>
    <url>/blog/2020/08/08/NLP-%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E4%B9%8BPGN%E6%8C%87%E9%92%88%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>NLP</category>
        <category>文本生成</category>
      </categories>
      <tags>
        <tag>PGN</tag>
      </tags>
  </entry>
  <entry>
    <title>[AI] 模型部署实践（1）Gunicorn + Falcon + Model</title>
    <url>/blog/2020/08/31/NLP-%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%EF%BC%881%EF%BC%89Gunicorn-Falcon-Model/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>AI</category>
        <category>模型部署</category>
      </categories>
      <tags>
        <tag>HTTP 部署</tag>
      </tags>
  </entry>
  <entry>
    <title>[Kubernetes] 基于kubeadm搭建一个完整的Kubernetes集群</title>
    <url>/blog/2020/09/29/Kubernetes-%E5%9F%BA%E4%BA%8Ekubeadm%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Kubernetes%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 是 Google 于 2014 年 6 月基于其内部使用的 Borg 系统开源出来的容器编排调度引擎，Google 将其作为初始和核心项目贡献给 CNCF（云原生计算基金会），近年来逐渐发展出了云原生生态。</p>
<p>Kubernetes 的目标不仅仅是一个编排系统，而是提供一个规范用以描述集群的架构，定义服务的最终状态，使系统自动地达到和维持该状态。Kubernetes 作为云原生应用的基石，相当于一个云操作系统，其重要性不言而喻。</p>
<h3 id="为什么需要-Kubernetes，它能做什么"><a href="#为什么需要-Kubernetes，它能做什么" class="headerlink" title="为什么需要 Kubernetes，它能做什么?"></a>为什么需要 Kubernetes，它能做什么?</h3><p>容器是打包和运行应用程序的好方式。在生产环境中，您需要管理运行应用程序的容器，并确保不会停机。例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？</p>
<p>这就是 Kubernetes 的救援方法！Kubernetes 为您提供了一个可弹性运行分布式系统的框架。Kubernetes 会满足您的扩展要求、故障转移、部署模式等。例如，Kubernetes 可以轻松管理系统的 Canary 部署。</p>
<p>Kubernetes 能够提供以下一些功能：</p>
<a id="more"></a>
<ul>
<li>服务发现和负载均衡<br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果到容器的流量很大，    Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li>
<li>存储编排<br>Kubernetes 允许您自动挂载您选择的存储系统，例如本地存储、公共云提供商等。</li>
<li>自动部署和回滚<br>您可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为所需状态。例如，您可以自动化 Kubernetes 来为您的部署创建新容器，删除现有容器并将它们的所有资源用于新容器。</li>
<li>自动二进制打包<br>Kubernetes 允许您指定每个容器所需 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</li>
<li>自我修复<br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li>
<li>密钥与配置管理<br>Kubernetes 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li>
</ul>
<p>因此综上，我们需要好好学习 Kubernetes 这个强大的云操作系统，增强自身的竞争力。工欲善其事，必先利其器，本篇也是 Kubernetes 系列的第一篇博文，讲述如何利用 Kubeadm 这个工具来搭建一套供自己学习的 Kubernetes 集群。</p>
<h2 id="Kubeadm-到底是什么？"><a href="#Kubeadm-到底是什么？" class="headerlink" title="Kubeadm 到底是什么？"></a>Kubeadm 到底是什么？</h2><p>Kubeadm 能够用以创建一个符合最佳实践的最小化 Kubernetes 集群。事实上，你可以使用 kubeadm 配置一个通过 Kubernetes 一致性测试的集群。 kubeadm 还支持其他集群生命周期功能， 例如：启动引导令牌和集群升级。</p>
<p>kubeadm 工具很棒，如果你需要：</p>
<ul>
<li>一个尝试 Kubernetes 的简单方法。</li>
<li>一个现有用户可以自动设置集群并测试其应用程序的途径。</li>
<li>其他具有更大范围的生态系统和/或安装工具中的构建模块。</li>
</ul>
<p>你可以在各种机器上安装和使用 kubeadm：笔记本电脑， 一组云服务器，Raspberry Pi 等。无论是部署到云还是本地，你都可以将 kubeadm 集成到预配置系统中，例如 Ansible 或 Terraform。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>一台或多台运行着下列系统的机器，去阿里云申请或者自己物理机用 VMvare 新建都行：<ul>
<li>Ubuntu 16.04+</li>
<li>Debian 9+</li>
<li>CentOS 7</li>
<li>Red Hat Enterprise Linux (RHEL) 7</li>
<li>Fedora 25+</li>
<li>HypriotOS v1.0.1+</li>
<li>Container Linux (测试 1800.6.0 版本)</li>
</ul>
</li>
<li>单机可用资源建议 2 核 CPU、8 GB 内存或以上，再小的话问题也不大，但是能调度的 Pod 数量就比较有限了</li>
<li>每台机器能够访问外网，因为需要拉取镜像</li>
<li>集群中所有计算机之间具有完全的网络连接</li>
</ul>
<h2 id="安装-Kubeadm-以及-Docker"><a href="#安装-Kubeadm-以及-Docker" class="headerlink" title="安装 Kubeadm 以及 Docker"></a>安装 Kubeadm 以及 Docker</h2><p>上述介绍过 kubeadm 的基础用法，接下来我将会介绍基于 Centos 8 安装 Kubernetes 组件以及 Docker。</p>
<h3 id="配置安装源"><a href="#配置安装源" class="headerlink" title="配置安装源"></a>配置安装源</h3><ul>
<li>配置<code>docker</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>配置<code>kubernetes</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">repo_gpgcheck&#x3D;0</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
<li>本地缓存<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dnf makecache</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="安装-Kubeadm-以及-docker"><a href="#安装-Kubeadm-以及-docker" class="headerlink" title="安装 Kubeadm 以及 docker"></a>安装 Kubeadm 以及 docker</h3><ul>
<li>执行以下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dnf -y install docker-ce</span><br><span class="line">$ systemctl enable docker</span><br><span class="line">$ systemctl start docker</span><br><span class="line">$ dnf install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里安装了 Docker 公司发布的最新的 Docker CE（社区版），Kubernetes 相关的组件安装的 1.18.0 版本，基本是目前为止最新的版本了。</p>
<h2 id="部署-Kubernetes-的-Master-节点"><a href="#部署-Kubernetes-的-Master-节点" class="headerlink" title="部署 Kubernetes 的 Master 节点"></a>部署 Kubernetes 的 Master 节点</h2><p>利用 kubeadm 可以很简单的来初始化 kubernetes 集群的 master 节点，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address&#x3D;192.168.0.2 \</span><br><span class="line">  --kubernetes-version v1.18.0 \</span><br><span class="line">  --service-cidr&#x3D;10.1.0.0&#x2F;16 \</span><br><span class="line">  --pod-network-cidr&#x3D;10.244.0.0&#x2F;16</span><br><span class="line">  </span><br><span class="line"> If you can&#39;t access foreign websites:</span><br><span class="line">  kubeadm init \</span><br><span class="line">  --apiserver-advertise-address&#x3D;192.168.0.2 \</span><br><span class="line">  --image-repository registry.aliyuncs.com&#x2F;google_containers \</span><br><span class="line">  --kubernetes-version v1.18.0 \</span><br><span class="line">  --service-cidr&#x3D;10.1.0.0&#x2F;16 \</span><br><span class="line">  --pod-network-cidr&#x3D;10.244.0.0&#x2F;16</span><br></pre></td></tr></table></figure>
<p>上述命令行参数解释：</p>
<ul>
<li><code>--apiserver-advertise-address</code>：可用于为控制平面节点的 API server 设置广播地址，</li>
</ul>
<h2 id="部署网络插件"><a href="#部署网络插件" class="headerlink" title="部署网络插件"></a>部署网络插件</h2><p>在 Kubernetes 项目“一切皆容器”的设计理念指导下，部署网络插件也是通过启动<code>pod</code>的形式来配置网络，其中有两种网络插件可供部署：</p>
<ul>
<li>部署 flannel 网络插件（详细介绍后面会在开一篇博文）：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;a70459be0084506e4ec919aa1c114638878db11b&#x2F;Documentation&#x2F;kube-flannel.yml</span><br><span class="line">update:  https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;v0.12.0&#x2F;Documentation&#x2F;kube-flannel.yml</span><br></pre></td></tr></table></figure></li>
<li>部署 calico 网络插件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;docs.projectcalico.org&#x2F;v3.14&#x2F;manifests&#x2F;calico.yaml</span><br></pre></td></tr></table></figure>
上述两个网络插件只需部署一个即可，部署成功与否可通过查看对应 pod 的运行状态即可：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -n kube-system</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-65f8bc95db-ngv7v   1&#x2F;1     Running   0          3d19h</span><br><span class="line">calico-node-9sr5c                          1&#x2F;1     Running   0          3d19h</span><br><span class="line">calico-node-jtt5w                          1&#x2F;1     Running   0          3d19h</span><br><span class="line">coredns-7ff77c879f-v645l                   1&#x2F;1     Running   0          3d19h</span><br><span class="line">coredns-7ff77c879f-vdrcf                   1&#x2F;1     Running   0          3d19h</span><br><span class="line">etcd-master                                1&#x2F;1     Running   1          3d20h</span><br><span class="line">kube-apiserver-master                      1&#x2F;1     Running   1          3d20h</span><br><span class="line">kube-controller-manager-master             1&#x2F;1     Running   1          3d20h</span><br><span class="line">kube-proxy-sbxzb                           1&#x2F;1     Running   0          3d19h</span><br><span class="line">kube-proxy-xfw7t                           1&#x2F;1     Running   0          3d19h</span><br><span class="line">kube-scheduler-master                      1&#x2F;1     Running   1          3d20h</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以看到，所有的系统 Pod 都成功启动了，而刚刚部署的 calico 网络插件则在 kube-system 下面新建了一个名叫 calico-kube-controllers-65f8bc95db-ngv7v 的 Pod，一般来说，这些 Pod 就是容器网络插件在每个节点上的控制组件。</p>
<p>Kubernetes 支持容器网络插件，使用的是一个名叫 CNI 的通用接口，它也是当前容器网络的事实标准，市面上的所有容器网络开源项目都可以通过 CNI 接入 Kubernetes，比如 Flannel、Calico、Canal、Romana 等等，它们的部署方式也都是类似的“一键部署”。关于这些开源项目的实现细节和差异，后续会有相关的博文进行详细讲解。</p>
<p>至此，Kubernetes 的 Master 节点就部署完成了。如果你只需要一个单节点的 Kubernetes，现在你就可以使用了。不过，在默认情况下，Kubernetes 的 Master 节点是不能运行用户 Pod 的，所以还需要额外做一个小操作。在本篇的最后部分，我会介绍到它。</p>
<h2 id="部署-Kubernetes-的计算节点"><a href="#部署-Kubernetes-的计算节点" class="headerlink" title="部署 Kubernetes 的计算节点"></a>部署 Kubernetes 的计算节点</h2><p>Kubernetes 的 计算节点跟 Master 节点几乎是相同的，它们运行着的都是一个 kubelet 组件。唯一的区别在于，在 kubeadm init 的过程中，kubelet 启动后，Master 节点上还会自动运行 kube-apiserver、kube-scheduler、kube-controller-manger 这三个系统 Pod。<br>执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubeadm join 192.168.56.12:6443 --token japatq.5vib0jhpgmeeqsb2 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c08f2729dbe9e2b1ce9f44e6d3159c493cc686b2e93dc252f7658cb26b87d726</span><br></pre></td></tr></table></figure>
<p>用以加入<code>192.168.56.12</code>这个 IP 的计算节点到集群中，以上<code>Token</code>可用<code>kubeclt token list</code>得到。</p>
<p>通过执行以上步骤便可以搭建好一个网络完整的 Kubernetes 集群。当然，也可以继续往集群中添加其他的插件，比如部署 Dashboard 可视化插件，部署容器存储插件等等。这个就因人而异了，留给大家自由发挥了…</p>
<h2 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h2><ul>
<li>列出集群的节点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES    AGE   VERSION</span><br><span class="line">master   Ready    master   33d   v1.18.0</span><br><span class="line">node     Ready    &lt;none&gt;   33d   v1.18.0</span><br></pre></td></tr></table></figure></li>
<li>列出系统的<code>pod</code>资源<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get pod -n kube-system</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">calico-kube-controllers-65f8bc95db-ngv7v   1&#x2F;1     Running   0          33d</span><br><span class="line">calico-node-9sr5c                          1&#x2F;1     Running   0          33d</span><br><span class="line">calico-node-jtt5w                          1&#x2F;1     Running   0          33d</span><br><span class="line">coredns-7ff77c879f-v645l                   1&#x2F;1     Running   0          33d</span><br><span class="line">coredns-7ff77c879f-vdrcf                   1&#x2F;1     Running   0          33d</span><br><span class="line">etcd-master                                1&#x2F;1     Running   1          33d</span><br><span class="line">kube-apiserver-master                      1&#x2F;1     Running   1          33d</span><br><span class="line">kube-controller-manager-master             1&#x2F;1     Running   1          33d</span><br><span class="line">kube-proxy-sbxzb                           1&#x2F;1     Running   0          33d</span><br><span class="line">kube-proxy-xfw7t                           1&#x2F;1     Running   0          33d</span><br><span class="line">kube-scheduler-master                      1&#x2F;1     Running   1          33d</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">使用 kubeadm 创建集群</a></li>
<li><a href="https://kubernetes.io/zh/docs/concepts/overview/" target="_blank" rel="noopener">Kubernetes概述</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubeadm</tag>
        <tag>k8s集群</tag>
      </tags>
  </entry>
  <entry>
    <title>[AI] 模型部署实践（2）Tensorflow Serving 部署方式</title>
    <url>/blog/2020/09/29/AI-%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%EF%BC%882%EF%BC%89Tensorflow-Serving%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>AI</category>
        <category>模型部署</category>
      </categories>
      <tags>
        <tag>TF Serving</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode] 数据结构之树</title>
    <url>/blog/2020/10/18/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>刷题</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
</search>
